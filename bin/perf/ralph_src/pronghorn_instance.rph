Struct RoutingTableEntry
{
    TVar TrueFalse active;
    // ipv4 addresses specified as a.b.c.d
    TVar Text src_ip;
    TVar Text dst_ip;
    // See
    // http://www.openflowhub.org/display/floodlightcontroller/Static+Flow+Pusher+API+%28New%29
    // for list of supported actions.    
    TVar Text action;    
}

Struct Switch
{
    // unique id for each switch
    TVar Text switch_id;    
    TVar Number available_capacity;
    TVar List (element: Struct RoutingTableEntry) rtable;
}

Endpoint Pronghorn
{
    TVar Map(from: Text, to: Struct Switch) instance_switches;

    add_switch(Text switch_id)
    {
        Struct Switch switcher;
	instance_switches.set(switch_id,switcher);
    }

    switch_failure(Text switch_id)
    {
	instance_switches.remove(switch_id);
    }

    num_switches() returns Number
    {
        return instance_switches.size();
    }

    list_switch_ids() returns List(element:Text)
    {
        List(element: Text) switch_ids;
        for (Text switch_id in instance_switches)
            switch_ids.append(switch_id);
        return switch_ids;
    }
    
    /**
       If have a switch corresponding to switch_id, then 
     */
    single_op(Text switch_id) returns TrueFalse
    {
        TrueFalse had_switch = False;
        atomically {
            if (instance_switches.contains(switch_id))
            {
                had_switch = True;
                Struct Switch target_switch = instance_switches.get(switch_id);

                if (target_switch.rtable.size() != 0)
                    target_switch.rtable.clear();
                else
                {
                    Struct RoutingTableEntry to_add;
                    to_add.active = True;
                    to_add.src_ip = '18.18.18.18';
                    to_add.dst_ip = '18.18.18.19';
                    // drop all packets
                    to_add.action = '';
                    target_switch.rtable.append(to_add);
                }
            }
            else
                had_switch = False;
        }
        return had_switch;
    }
    
    block_traffic_all_switches(Text src_ip, Text dst_ip)
    {
        atomically
        {
            for (Text switch_id in instance_switches)
            {
                Struct Switch switch_to_add_to = instance_switches.get(switch_id);

                Struct RoutingTableEntry to_add;
                to_add.active = True;
                to_add.src_ip = src_ip;
                to_add.dst_ip = dst_ip;
                // send packet out all ports
                //to_add.action = 'output=flood';
                // drop packet
                to_add.action = '';
                
                switch_to_add_to.rtable.append(to_add);
            }
        }
    }

    remove_first_entry_all_switches()
    {
        atomically
        {
            for (Text switch_id in instance_switches)
            {
                Struct Switch switch_to_remove_from =
                    instance_switches.get(switch_id);
                if (switch_to_remove_from.rtable.size() > 0)
                    switch_to_remove_from.rtable.remove(0);
            }
        }
    }
}
