import ralph.parse.ast_labels as ast_labels
from ralph.java_emit.emit_utils import indent_string
from ralph.java_emit.emit_context import EmitContext
from ralph.parse.type import BasicType,MethodType,WildcardType
from ralph.parse.type import MapType,StructType,ListType,EndpointType
from ralph.parse.type import ServiceFactoryType, ServiceReferenceType
from ralph.parse.type import EnumType
from ralph.parse.ast_labels import BOOL_TYPE, NUMBER_TYPE, STRING_TYPE,NULL_TYPE
from ralph.java_emit.emit_utils import InternalEmitException

def emit(root_node,struct_types_ctx,package_name,program_name):
    '''
    @param {RootStatementNode} root_node
    
    @returns {String} --- Emitted program text
    '''

    prog_txt = '''// Automatically generated by the ralph compiler.
// DO NOT EDIT!

package %s;

import ralph.*;
import ralph.Variables.AtomicNumberVariable;
import ralph.Variables.AtomicTextVariable;
import ralph.Variables.AtomicTrueFalseVariable;
import ralph.Variables.NonAtomicNumberVariable;
import ralph.Variables.NonAtomicTextVariable;
import ralph.Variables.NonAtomicTrueFalseVariable;
import ralph.Variables.NonAtomicMapVariable;
import ralph.Variables.AtomicMapVariable;
import ralph.Variables.NonAtomicInterfaceVariable;
import ralph.Variables.AtomicInterfaceVariable;
import ralph.Variables.NonAtomicServiceFactoryVariable;
import ralph.Variables.AtomicServiceFactoryVariable;
import ralph.Variables.NonAtomicServiceReferenceVariable;
import ralph.Variables.AtomicServiceReferenceVariable;
import ralph.Variables.NonAtomicEnumVariable;
import ralph.Variables.AtomicEnumVariable;

import ralph.BaseMapVariableFactory.MapVariableFactory;
import ralph.BaseListVariableFactory.ListVariableFactory;

import ralph.Variables.NonAtomicListVariable;
import ralph.Variables.AtomicListVariable;

import RalphVersions.IVersionSaver;
import RalphVersions.IVersionReplayer;
import RalphVersions.IReconstructionContext;
import RalphVersions.ObjectHistory;
import RalphVersions.EnumSerializer;

import RalphConnObj.ConnectionObj;
import RalphConnObj.SingleSideConnection;
import RalphExceptions.*;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;
import ralph.Util;
import java.util.concurrent.ArrayBlockingQueue;

import RalphAtomicWrappers.BaseAtomicWrappers;
import RalphAtomicWrappers.EnsureAtomicWrapper;
import RalphDataWrappers.ValueTypeDataWrapperFactory;
import ralph.ActiveEvent.FirstPhaseCommitResponseCode;
import RalphCallResults.RootCallResult;

import ralph.EventPriority.IsSuperFlag;
import ralph.EndpointConstructorObj;

import ralph_protobuffs.ObjectContentsProto.ObjectContents;
import ralph_protobuffs.DeltaProto.Delta;

public class %s
{
''' % (package_name,program_name)

    # emit individual struct types
    prog_txt += indent_string(
        '/*********** STRUCT DEFINITIONS ******/\n')
    for struct_name in struct_types_ctx:
        struct_type = struct_types_ctx.get_type_obj_from_struct_name(struct_name)
        prog_txt += indent_string(
            emit_struct_definition(struct_name,struct_type,struct_types_ctx))
        prog_txt += '\n'
        
    # emit individual enum types
    prog_txt += indent_string(
        '/*********** ENUM DEFINITIONS ******/\n')
    enum_ctx = struct_types_ctx.enum_ctx
    for enum_name in enum_ctx:
        enum_type = enum_ctx.get_enum_type_obj_from_enum_name(enum_name)
        prog_txt += indent_string(
            emit_enum_definition(enum_name,enum_type,struct_types_ctx))
        prog_txt += '\n'
        
    # emit individual interfaces
    prog_txt += indent_string(
        '/*********** INTERFACE DEFINITIONS ******/\n')
    for interface_node in root_node.interface_node_list:
        prog_txt += indent_string(
            emit_interface(interface_node,struct_types_ctx))
        prog_txt += '\n'
        
    # emit individual endpoints
    prog_txt += indent_string(
        '/*********** ENDPOINT DEFINITIONS ******/\n')
    for endpt_node in root_node.endpoint_node_list:
        prog_txt += indent_string(emit_endpt(endpt_node,struct_types_ctx))
        prog_txt += '\n'

    prog_txt += '}' # closes class program_name

    return prog_txt

def emit_interface(interface_node,struct_types_ctx):
    emit_ctx = EmitContext(struct_types_ctx)
    emit_ctx.push_scope()
    
    # contains emitted code that actually gets returned
    interface_signature = '''
public static interface %s extends IReference {
''' % interface_node.name

    interface_body = ''
    
    body_node = interface_node.body_node
    for iface_method_decl_node in body_node.method_declaration_nodes:
        # internal signature
        internal_method_text, garbage = emit_internal_method_signature(
            emit_ctx,iface_method_decl_node.method_signature_node)
        interface_body += internal_method_text
        interface_body += ';\n'

        # external signature with super arg
        signature, garbage, garbage, garbage = emit_external_signature(
            emit_ctx,iface_method_decl_node.method_signature_node,True)
        interface_body += signature
        interface_body += ';\n'
        # external signature without super arg
        signature, garbage, garbage, garbage = emit_external_signature(
            emit_ctx,iface_method_decl_node.method_signature_node,False)
        interface_body += signature
        interface_body += ';\n\n\n'
        
    interface_signature = (
        interface_signature + indent_string(interface_body) + '}\n')

    emit_ctx.pop_scope()
    return interface_signature

def produce_what_implements(variable_type_node_list):
    '''Adds implement text to end of service/endpoint definition.

    Args:
        variable_type_node_list: List, each element is a
        VariableTypeNode.

    Returns:
    
        String.  Containing the implements suffix for a class
        declaration in Java.  Eg., '' if variable_type_node_list is
        empty, 'implements Something1, Something2' if two elements in
        variable_type_node_list, etc.
    '''
    if len(variable_type_node_list) == 0:
        return ''

    internal_types_text = map (
        lambda internal_type_node: emit_internal_type(internal_type_node.type),
        variable_type_node_list)
    return 'implements ' + ','.join(internal_types_text)

def emit_endpt(endpt_node,struct_types_ctx):
    '''
    @param {EndpointDefinitionNode} endpt_node

    @returns {String}
    '''
    emit_ctx = EmitContext(struct_types_ctx)
    emit_ctx.push_scope()

    implements_text = produce_what_implements(
        endpt_node.implements_variable_type_node_list)
    
    endpt_class_signature = '''
public static class %s extends Endpoint %s {
''' % (endpt_node.name, implements_text)

    endpt_class_body = emit_endpt_variable_declarations(
        emit_ctx,endpt_node.body_node.variable_declaration_nodes)
    endpt_class_body += '\n'
    endpt_class_body += emit_constructor(emit_ctx,endpt_node)
    endpt_class_body += emit_endpt_method_declarations(
        emit_ctx,endpt_node.body_node.method_declaration_nodes)
    endpt_class_body += '\n'
    endpt_class_body += emit_rpc_dispatch(
        emit_ctx,endpt_node.body_node.method_declaration_nodes)
    endpt_class_body += '\n'
    return endpt_class_signature + indent_string(endpt_class_body) + '\n}'


def emit_constructor(emit_ctx,endpt_node):
    # when initially construct an endpoint/service, if versioning is
    # on, should map the endpoint's global variables to the ralph
    # objects that they point to.  These mappings can then be used
    # during reconstruction to rebuild the endpoint and its associated
    # state.
    version_mapping_text = ''

    # each element of the following list is a DeclarationStatementNode
    endpt_variable_decl_node_list = (
        endpt_node.body_node.variable_declaration_nodes)
    for endpt_variable_decl_node in endpt_variable_decl_node_list:
        var_name = endpt_variable_decl_node.var_name
        internal_var_name = emit_ctx.lookup_internal_var_name(var_name)
        version_mapping_text += ('''
version_saver.save_endpoint_global_mapping(
    "%(variable_name)s",%(variable_name)s.uuid(), _uuid,
    factory.getClass().getName(), local_lamport_time);''' %
        { 'variable_name': internal_var_name })
        
    # line up with internal if statements
    version_mapping_text = indent_string(version_mapping_text,2)

    # this text is used in endpointconstructorobject.  Its purpose is
    # to initialize internal data of endpoint to internal_values_list,
    # specified in construct method.
    version_unmapping_text = ''
    for initializer_index in range(0, len(endpt_variable_decl_node_list)):
        endpt_variable_decl_node = (
            endpt_variable_decl_node_list[initializer_index])

        java_type_statement = emit_ralph_wrapped_type(
            endpt_variable_decl_node.type)
        var_name = endpt_variable_decl_node.var_name
        internal_var_name = emit_ctx.lookup_internal_var_name(var_name)
        version_unmapping_text += '''
to_return.%(internal_var_name)s = ( %(variable_type)s ) internal_values_list.get( %(initializer_index)i);
''' % {'internal_var_name': internal_var_name,
       'initializer_index': initializer_index,
       'variable_type': java_type_statement}
    # line up with construct method
    version_unmapping_text = indent_string(version_unmapping_text,2)
    
    constructor_text = '''
public %(endpoint_name)s ( RalphGlobals ralph_globals,ConnectionObj conn_obj) 
{
    super(ralph_globals,conn_obj,factory);

    if (VersioningInfo.instance.version_saver != null)
    {
        long local_lamport_time =
            ralph_globals.clock.get_and_increment_int_timestamp();
        // map names of endpoint variables to their local values.
        IVersionSaver version_saver =
            VersioningInfo.instance.version_saver;
        %(version_mapping_text)s
    }
}

public static class %(endpoint_name)s_ConstructorObj implements EndpointConstructorObj
{
    // This should be public because need to be able to build object
    // when sending over reference factories.
    public %(endpoint_name)s_ConstructorObj()
    {
        IVersionSaver version_saver =
            VersioningInfo.instance.version_saver;
        if (version_saver != null)
        {
            version_saver.save_endpoint_constructor_obj(this);
        }
    }

    @Override
    public Endpoint construct (RalphGlobals ralph_globals, ConnectionObj conn_obj)
    {
        return new %(endpoint_name)s(ralph_globals,conn_obj);
    }

    @Override
    public Endpoint construct (
        RalphGlobals ralph_globals, ConnectionObj conn_obj,
        List<RalphObject> internal_values_list)
    {
        %(endpoint_name)s to_return =  new %(endpoint_name)s(ralph_globals,conn_obj);
        %(version_unmapping_text)s
        return to_return;
    }
}

public final static EndpointConstructorObj factory = new %(endpoint_name)s_ConstructorObj();

''' % ({'endpoint_name': endpt_node.name,
        'version_mapping_text': version_mapping_text,
        'version_unmapping_text': version_unmapping_text})
    return constructor_text


def emit_endpt_variable_declarations(emit_ctx,variable_declaration_node_list):
    '''
    @param {list} variable_declaration_node_list --- Each element is
    a DeclarationStatementNode.
    '''
    emit_ctx.set_in_endpoint_global_vars(True)
    endpoint_variable_text = ''
    for variable_declaration_node in variable_declaration_node_list:
        endpoint_variable_text += (
            emit_statement(emit_ctx,variable_declaration_node) )
        
    emit_ctx.set_in_endpoint_global_vars(False)
    return endpoint_variable_text

def convert_args_text_for_dispatch(method_declaration_node):
    '''
    When emitting rpc dispatch method for each endpoint, must convert
    args passed in to method into args that the method will use.

    This method returns a text string that contains all the argument
    casts necessary to call internal methods.  Eg.,

    Double arg0 = ((RalphObject<Double,Double>)args[0]).get_val(null);

    Note that it is dumb that we deserialize into a locked object,
    instead of the value directly.  Should change.

    If method has return value, then put the result into variable
    named result.
    
    @param {int} index --- Which value of args array to read from and
    how to name transalted arg (eg., "arg0" above instead of "arg1" or
    "arg2".)
    '''
    #FIXME: when deserialize should deserialize into a java native
    #object instead of a locked object.

    method_declaration_arg_node_list = (
        method_declaration_node.method_signature_node.method_declaration_args)

    to_return = ''
    for arg_number in range(0,len(method_declaration_arg_node_list)):
        method_declaration_arg_node = method_declaration_arg_node_list[arg_number]
        arg_name = 'arg%i' % arg_number
        arg_vec_to_read_from = 'args[%i]' % arg_number

        if (isinstance(method_declaration_arg_node.type, MapType) or
            isinstance(method_declaration_arg_node.type, ListType)):
            internal_container_type = emit_internal_type(method_declaration_arg_node.type)
            wrapped_container_type = emit_ralph_wrapped_type(method_declaration_arg_node.type)

            single_arg_string = '''
%(internal_container_type)s %(arg_name)s =
    (%(arg_vec_to_read_from)s == null) ? null : ((%(wrapped_container_type)s) %(arg_vec_to_read_from)s).get_val(active_event);\n
''' % { 'internal_container_type': internal_container_type,
        'arg_name': arg_name,
        'arg_vec_to_read_from': arg_vec_to_read_from,
        'wrapped_container_type': wrapped_container_type}

        elif isinstance(method_declaration_arg_node.type, ServiceFactoryType):
            ## FIXME: Allow serializing service factories.
            single_arg_string = (
                '''InternalServiceFactory %s = ((RalphObject<InternalServiceFactory,InternalServiceFactory>) %s).get_val(active_event);\n''' %
                (arg_name,arg_vec_to_read_from))
            
        elif isinstance(method_declaration_arg_node.type, StructType):
            internal_struct_type = emit_internal_struct_type(
                method_declaration_arg_node.type)
            # for struct types, just push the struct variable directly
            # as argument to method
            struct_type_name = method_declaration_arg_node.type.struct_name
            single_arg_string = (
                '%s %s = (%s == null) ? null : ((%s) %s).get_val(active_event);\n' %
                (internal_struct_type, arg_name, arg_vec_to_read_from,struct_type_name,
                 arg_vec_to_read_from))
        elif isinstance(method_declaration_arg_node.type,EnumType):
            internal_struct_type = emit_internal_enum_type(
                method_declaration_arg_node.type)
            # for enum types, just push the struct variable directly
            # as argument to method
            enum_type_name = method_declaration_arg_node.type.get_emit_name()
            wrapped_enum_type_name = (
                'RalphObject<%s,%s>' % (enum_type_name,enum_type_name))
            single_arg_string = (
                '%s %s = (%s == null) ? null : ((%s) %s).get_val(active_event);\n' %
                (internal_struct_type, arg_name, arg_vec_to_read_from,
                 wrapped_enum_type_name,arg_vec_to_read_from))
            
        elif isinstance(method_declaration_arg_node.type, EndpointType):
            # note: unable to dispatch for rpc for methods that
            # requires endpoint argument because cannot pass endpoint
            # references through network.  Currently, just setting
            # endpoint to null.
            endpoint_alias = method_declaration_arg_node.type.alias_name
            single_arg_string = ('''
%s %s = null; /** WARN: cannot receive partner request with endpoint arg.*/'''
                                 % (endpoint_alias,arg_name))
        else:
            locked_type,java_type = get_method_arg_type_as_locked(
            method_declaration_arg_node)

            single_arg_string = '''
%s %s = (%s == null) ? null : ((%s)%s).get_val(null);
''' % (java_type,arg_name,arg_vec_to_read_from, locked_type,arg_vec_to_read_from)

            
        to_return += single_arg_string
    return to_return

def get_method_arg_type_as_locked(method_declaration_arg_node):
    '''
    Takes in a method's declared argument ast node and returns a
    string for a RalphObject of that type.  Eg., if
    method_declaration_arg_node has type Number, return
      RalphObject<Double,Double>, Double
    String, return:
      RalphObject<String,String>, String
    Boolean, return:
      RalphObject<Boolean,Boolean>, Boolean
    '''
    if isinstance(method_declaration_arg_node.type,BasicType):
        arg_basic_type = method_declaration_arg_node.type.basic_type
        if arg_basic_type == BOOL_TYPE:
            java_type = 'Boolean'
        elif arg_basic_type == NUMBER_TYPE:
            java_type = 'Double'
        elif arg_basic_type == STRING_TYPE:
            java_type = 'String'
        #### DEBUG
        else:
            raise InternalEmitException(
                method_declaration_arg_node.filename,
                method_declaration_arg_node.line_number,
                'Unknown basic type when emitting.')
        #### END DEBUG
        return ('RalphObject<%s,%s>' % (java_type,java_type)), java_type
    
    #### DEBUG
    else:
        raise InternalEmitException(
            method_declaration_arg_node.filename,
            method_declaration_arg_node.line_number,
            'Unknown argument type for method.')
    #### END DEBUG
        

def exec_dispatch_sequence_call(method_declaration_node,emit_ctx):
    '''
    When emitting rpc dispatch method, this method actually executes
    method call associated with method_declaration_node, assuming that
    convert_args_text_for_dispatch has run and put the method's
    arugments into arg0, arg1, arg2, etc.
    '''
    method_name = method_declaration_node.method_name
    method_declaration_arg_node_list = (
        method_declaration_node.method_signature_node.method_declaration_args)

    # assumes that all arguments are named arg0, arg1, arg2,
    # etc. (should be based on running convert_args_text_for_dispatch.
    arg_list = map(
        lambda arg_number:
            'arg%i'%arg_number,
        range(0,len(method_declaration_arg_node_list)))
    
    args_text = ','.join(arg_list)
    if args_text != '':
        args_text = ',' + args_text

    actual_call = method_name + '(ctx,active_event' + args_text + ')'
    if method_declaration_node.returns_value():
        return_type = method_declaration_node.get_return_type()
        new_expression = (
            'result = %s;\n' %
            construct_new_expression(return_type,None,emit_ctx))
        assignment_statement = (
            'result.set_val(active_event,%s);' %
            actual_call)
        actual_call = new_expression + assignment_statement

    return actual_call + ';\n'


def emit_rpc_dispatch(emit_ctx,method_declaration_node_list):
    '''
    Each endpoint has a method for dispatching rpcs that takes in the
    name of the method to execute locally as well as Object arguments
    to that method.  This method then actually executes the local
    method associated with the rpc call.
    '''
    # contains actual if-else if-else logic for dispatch method.
    rpc_text_for_methods = ''
    first = True
    for index in range(0,len(method_declaration_node_list)):
        method_declaration_node = method_declaration_node_list[index]
        # trying to add something like:
        # else if (to_exec_internal_name.equals("test_partner_args_method"))
        # {
        #     RalphObject<Double,Double> num_obj =
        #         (RalphObject<Double,Double>)args[0];
        #     _test_partner_args_method(active_event, ctx, num_obj);
        #     ctx.hide_sequence_completed_call(this, active_event);
        # }
        # to method body.

        # whether is if or else if
        if_elif = 'else if'
        if first:
            first = False
            if_elif = 'if'

        # contents of if-elif statement
        if_elif_body = (
            convert_args_text_for_dispatch(method_declaration_node) +
            exec_dispatch_sequence_call(method_declaration_node,emit_ctx))

        rpc_text_for_methods += (
            if_elif + '(to_exec_internal_name.equals("' +
            method_declaration_node.method_name + '")) {\n' + 
            indent_string(if_elif_body,1) + 
            '\n}\n')
        
    #### For debugging: what happens if asked to run an rpc method
    #### that isn't available locally.
    if rpc_text_for_methods != '':
        rpc_text_for_methods += '''
else
{
    Util.logger_assert(
        "Error handling rpc call: unknown method " +
        to_exec_internal_name);
}

'''
    #### End debug
        
    emitted_method = '''
protected RalphObject _handle_rpc_call(
    String to_exec_internal_name,ActiveEvent active_event,
    ExecutingEventContext ctx,
    Object...args)
    throws ApplicationException, BackoutException, NetworkException,
    StoppedException
{
    RalphObject result = null;

%s

    return result;
}
''' % indent_string(rpc_text_for_methods,1)

    return emitted_method


def emit_endpt_method_declarations(emit_ctx,method_declaration_node_list):
    '''
    @param {list} method_declaration_node_list --- Each element is a
    MethodDeclarationNode.
    '''
    to_return = ''

    # first, for each node, load the method name into emit_ctx so can
    # reference it later.
    for method_declaration_node in method_declaration_node_list:
        add_method_signature_to_ctx(emit_ctx,method_declaration_node)
    
    for method_declaration_node in method_declaration_node_list:
        to_return += emit_method_declaration_node(
            emit_ctx,method_declaration_node)
        to_return += '\n'

    return to_return

def add_method_signature_to_ctx(emit_ctx,method_declaration_node):
    """Add method signature to emit_ctx so that can reference it
    later in lookup to emit_ctx
    """
    method_signature_node = method_declaration_node.method_signature_node
    emit_ctx.add_method_name_to_method_set(method_signature_node.method_name)

def emit_method_declaration_node(emit_ctx,method_declaration_node):
    '''
    @param {MethodDeclarationNode} method_declaration_node
    '''
    external_method_text = emit_external_facing_method(
        emit_ctx,method_declaration_node.method_signature_node)
    
    emit_ctx.push_scope()
    signature_plus_head = emit_method_signature_plus_head(
        emit_ctx,
        method_declaration_node.method_signature_node)

    body = ''
    for statement in method_declaration_node.method_body_statement_list:
        body += indent_string(emit_statement(emit_ctx,statement))
        body += indent_string(emit_semicolon_line_break(statement))
        
    emit_ctx.pop_scope()

    # all method bodies are defined in try-finally blocks.  At
    # beginning of try-finally, push to context var stack.  At end,
    # pop from it.
    body += '\n} finally {}'
    internal_method_text = signature_plus_head + indent_string(body) + '\n}'
    
    return external_method_text + internal_method_text

def emit_semicolon_line_break(statement_node):
    '''
    If statement node is not a scope, then add a semi-colon on end
    '''
    if statement_node.label == ast_labels.SCOPE:
        return '\n'
    return ';\n'

def emit_external_signature(emit_ctx,method_signature_node,with_super_arg):
    '''Have two externally-facing signatures.  One explicitly requires
    user to pass in a flag as to whether running the event should
    execute with super priority, or just standard/boosted priority.
    The other doesn't have this option, and just defaults to
    using standard/boosted priorities.
    '''
    return_type = 'void'
    void_return_type = True

    if method_signature_node.type.returns_type is not None:
        return_type = emit_internal_type(method_signature_node.type)
        void_return_type = False

    to_return = (
        'public %s %s (' % (return_type, method_signature_node.method_name) )
    argument_text_list = []
    argument_name_text_list = []
    for argument_node in method_signature_node.method_declaration_args:
        # for placing the arguments actually in method signature
        argument_type_text = emit_internal_type(argument_node.type)
        argument_name_text = argument_node.arg_name
        argument_text_list.append(
            argument_type_text + ' ' + argument_name_text)

        # for putting arguments into internal function call
        argument_name_text_list.append(argument_name_text)

    if with_super_arg:
        # note do not append to argument_name_text_list because do not
        # pass superflag on to internal calls.
        argument_text_list.append(
            'IsSuperFlag ' + super_flag_argument())
        
    # finish method signature
    to_return += ','.join(argument_text_list) + ') throws Exception '
    return to_return,return_type,void_return_type,argument_name_text_list
    
def super_flag_argument():
    return '__is_super_flag_arg___'


def emit_external_method_body(
    emit_ctx,method_signature_node,with_super_arg,
    return_type, void_return_type, argument_name_text_list):
    '''
    All these arguments should pretty much been produced by
    emit_external_signature.
    
    @param{list} argument_name_text_list --- Note: does not include
    super argument in list.  
    '''

    # finish method signature
    to_return = ' {\n'

    # call the internal version of the function
    method_body_text = 'ExecutingEventContext ctx = create_context();\n'

    if with_super_arg:
        # check if should create the root active event as an active
        # event with super priority.
        method_body_text += '''
NonAtomicActiveEvent active_event = null;
if (%(super_argument_flag)s == IsSuperFlag.SUPER)
    active_event = _act_event_map.create_super_root_non_atomic_event(
        this,"%(event_entry_point_name)s");
else
    active_event = _act_event_map.create_root_non_atomic_event(
        this,"%(event_entry_point_name)s");
''' % {
            'super_argument_flag': super_flag_argument(),
            'event_entry_point_name': method_signature_node.method_name
            }
    else:
        method_body_text += '''
NonAtomicActiveEvent active_event =
    _act_event_map.create_root_non_atomic_event(
        this,"%(event_entry_point_name)s");
''' % {
            'event_entry_point_name': method_signature_node.method_name
            }

    # check whether to perform a durability call
    # update context with loaded arguments
    ralph_wrapped_arg_names_list = []
    emit_ctx.push_scope()
    for argument_node in method_signature_node.method_declaration_args:
        arg_name = argument_node.arg_name
        emit_ctx.add_var_name(arg_name)
        ralph_wrapped_arg_names_list.append(
            emit_ctx.lookup_internal_var_name(arg_name))

    ralph_wrapped_arguments_text = method_args_to_ralph_wrapped_types(
        emit_ctx, method_signature_node,argument_name_text_list)
        
    method_body_text += '''

if (DurabilityInfo.instance.durability_saver != null)
{
    // If durability is turned on, then package contents of call so
    // that will be able to replay them later.

%(ralph_wrapped_arguments_text)s;

    List <RalphObject> args = new ArrayList<RalphObject>(
        Arrays.asList(%(ralph_wrapped_args_list)s));

    active_event.durability_entry_call(
        PartnerRequestSequenceBlockProducer.produce_request_block(
            null,"%(func_name)s", args, null,active_event,false,
            "-1" /* Empty reply with for entry call*/),
        _uuid);
}

''' % {
        'func_name': method_signature_node.method_name,
        'ralph_wrapped_arguments_text': ralph_wrapped_arguments_text,
        'ralph_wrapped_args_list': ','.join(ralph_wrapped_arg_names_list)
        }
    emit_ctx.pop_scope()

    inner_method_call_text = (
        '%s (ctx ,active_event' % method_signature_node.method_name)
    for argument_name in argument_name_text_list:
        inner_method_call_text += ',' + argument_name
    inner_method_call_text += ');\n'

    if not void_return_type:
        # assign the method call to an object to return
        inner_method_call_text = (
            '%s to_return = %s' % (return_type, inner_method_call_text))

    method_body_text += inner_method_call_text
    
    # try to commit the event
    method_body_text += '''
active_event.local_root_begin_first_phase_commit();
try {
    ((RootEventParent)active_event.event_parent).event_complete_queue.take();
} catch (InterruptedException _ex) {
    // TODO Auto-generated catch block
    _ex.printStackTrace();
}
'''

    # return the grabbed value
    if not void_return_type:
        method_body_text += 'return to_return;'
        
    to_return += indent_string(method_body_text) + '\n}\n' 
    return to_return


def emit_external_facing_method(emit_ctx,method_signature_node):
    """Methods can be called from both code within ralph and code
    external to ralph.  The external facing code requires different
    arguments and just calls into the internal code.

    There are two versions of external facing methods: one passes in
    an additional ralph.EventPriority.IsSuperFlag.  Using this
    signature, a programmer can start a potentially super transaction.
    Using the other signature, will always create standard/boosted
    transactions.
    """
    super_signature, return_type,void_return_type, argument_name_text_list = (
        emit_external_signature(emit_ctx,method_signature_node,True))

    super_body = emit_external_method_body(
        emit_ctx,method_signature_node,True,
        return_type, void_return_type, argument_name_text_list)

    super_method = super_signature + super_body


    non_super_signature, return_type,void_return_type, argument_name_text_list = (
        emit_external_signature(emit_ctx,method_signature_node,False))

    non_super_body = emit_external_method_body(
        emit_ctx,method_signature_node,False,
        return_type, void_return_type, argument_name_text_list)

    non_super_method = non_super_signature + non_super_body
    return super_method + '\n' + non_super_method



def method_args_to_ralph_wrapped_types(emit_ctx,method_signature_node,
                                       argument_name_text_list):
    '''
    Runs through method signature and produces code that wraps all
    arguments in Ralph wrappers.
    
    @param {} emit_ctx
    @param {MethodSignatureNode} method_signature_node
    
    @param {list} argument_name_text_list --- Each element of the list
    is a string that corresponds to the names of arguments (without
    types) as they will appear in the emitted method signature.
    '''
    to_return = ''
    
    # convert each method argument to ralph variable and then add to
    # stack.  Note: skip this step for maps, which caller already
    # cloned for us.
    for index in range(0,len(argument_name_text_list)):
        argument_name = argument_name_text_list[index]
        argument_node = method_signature_node.method_declaration_args[index]
        argument_type = argument_node.type

        reference_type = False
        if (isinstance(argument_type,MapType) or
            isinstance(argument_type,StructType) or
            isinstance(argument_type,ListType)):
            reference_type = True
            
        java_type_statement = emit_ralph_wrapped_type(argument_type,True)

        initializer = argument_name

        if isinstance(argument_type,MapType):
            key_type = argument_type.from_type_node.type
            value_type = argument_type.to_type_node.type
            key_type_class = class_from_element_type(key_type)
            value_type_class = class_from_element_type(value_type)

            internal_map_version_helper = (
                internal_map_version_helper_from_map_type(argument_type))
            
            new_ralph_variable = '''
new %(java_type_statement)s (
    false,
    %(argument_name)s,
    %(argument_name)s.locked_wrapper,
    %(internal_map_version_helper)s,
    %(key_type_class)s,
    %(value_type_class)s,ralph_globals)
''' % { 'java_type_statement': java_type_statement,
        'argument_name': argument_name,
        'key_type_class': key_type_class,
        'value_type_class': value_type_class,
        'internal_map_version_helper': internal_map_version_helper}
            
        elif isinstance(argument_type,ListType):
            element_type = argument_type.element_type_node.type
            element_type_class = class_from_element_type(element_type)
            new_ralph_variable = (
                'new %s (false,%s,%s.locked_wrapper,%s,ralph_globals)' %
                (java_type_statement,argument_name,argument_name,
                 element_type_class))

        elif isinstance(argument_type,StructType):
            new_ralph_variable = (
                'new %s (false,%s,ralph_globals)' %
                (java_type_statement,argument_name))
        elif isinstance(argument_type,EnumType):
            internal_enum_class_name = argument_type.get_emit_name()
            enum_constructor_obj_name = emit_fully_qualified_enum_constructor_obj_name(
                argument_type)
            enum_version_helper_obj_name = emit_fully_qualified_enum_version_helper_singleton_name(
                argument_type)
            new_ralph_variable = (
                'new %s (false,%s,%s,%s,ralph_globals)' %
                (java_type_statement,initializer,enum_constructor_obj_name,
                 enum_version_helper_obj_name))
        else:
            new_ralph_variable = (
                'new %s (false,%s,ralph_globals)' %
                (java_type_statement,argument_name))

        internal_arg_name = emit_ctx.lookup_internal_var_name(argument_name)
        to_return +=indent_string(
            '%s %s = %s;\n' %
            (java_type_statement,internal_arg_name,new_ralph_variable),2)

    return to_return

def emit_method_signature_plus_head(emit_ctx,method_signature_node):
    '''
    @param {EmitContext} emit_ctx --- Loads arguments to method into
    emit_ctx.

    @param {MethodSignatureNode} method_signature_node ---

    @returns {String} --- A java signature for method.  Eg.,

    private Double some_method (
        ExecutingEventContext _ctx, ActiveEvent _active_event,
        SomeType SomeVar) 
        throws ApplicationException, BackoutException, NetworkException,
        StoppedException
    {
        try {
    '''
    to_return,argument_name_text_list = emit_internal_method_signature(
        emit_ctx,method_signature_node)
    to_return += '{\n'
    
    # (starting at #3, because #1 and #2 are in
    # emit_internal_method_signature)
    # 3: emit head section where add to scope stack and push arguments
    # on to scope stack.  Must push arguments on to scope stack so
    # they're available in defer statements

    # note try block gets closed at end of
    # emit_method_declaration_node, near finally block.
    converted_args_text = 'try{ \n'
    converted_args_text += method_args_to_ralph_wrapped_types(
        emit_ctx,method_signature_node,argument_name_text_list)
    
    to_return += indent_string(converted_args_text)
    return to_return

def emit_internal_method_signature(emit_ctx,method_signature_node):
    '''
    Emits Java signature of method.

    Returns:
       2-tuple.  First element is a string containing the signature of
       the method.  The second element is a list containing strings of
       arguments.
    '''
    # 1: update context with loaded arguments
    for argument_node in method_signature_node.method_declaration_args:
        arg_name = argument_node.arg_name
        emit_ctx.add_var_name(arg_name)

    # 2: construct signature to return
    return_type = 'void'
    if method_signature_node.type is not None:
        return_type = emit_internal_type(method_signature_node.type)

    # this method is public so that can make calls into endpoints for
    # other endpoints and services.
    to_return = (
        'public %s %s (' % (return_type, method_signature_node.method_name) )
    to_return += 'ExecutingEventContext _ctx, ActiveEvent _active_event'
    
    argument_name_text_list = []
    for argument_node in method_signature_node.method_declaration_args:
        # for placing the arguments actually in method signature
        argument_type_text = emit_internal_type(argument_node.type)
        argument_name_text = argument_node.arg_name
        to_return += ', ' + argument_type_text + ' ' + argument_name_text

        # for putting arguments into scope at top of method
        argument_name_text_list.append(argument_name_text)

    to_return += (
        ') throws ApplicationException, BackoutException, ' +
        'NetworkException,StoppedException')
    return to_return, argument_name_text_list


def emit_ralph_wrapped_type(type_object,force_single_threaded=False):
    '''
    @param {Type or None} type_object --- None if type corresponds to
    void (eg., in method signature).

    @returns{String} --- Java-ized version of wrapped Ralph type: eg.,
    AtomicNumberVariable, etc.
    '''    
    if type_object is None:
        return 'void'

    # emit for maps
    if isinstance(type_object,MapType):
        return emit_map_type(type_object)

    # emit for lists
    if isinstance(type_object,ListType):
        return emit_list_type(type_object)

    # FIXME: ALLOW TVAR Structs????
    
    # emit for structs
    if isinstance(type_object,StructType):
        return type_object.struct_name

    # emit for enums
    if isinstance(type_object,EnumType):
        if type_object.is_tvar and (not force_single_threaded):
            return 'AtomicEnumVariable<%s>' % type_object.get_emit_name()
        return 'NonAtomicEnumVariable<%s>' % type_object.get_emit_name()
    
    # emit for endpoints
    if isinstance(type_object,EndpointType):
        if type_object.is_tvar and (not force_single_threaded):
            return 'AtomicInterfaceVariable<%s>' % type_object.alias_name
        return 'NonAtomicInterfaceVariable<%s>' % type_object.alias_name

    # emit for service factories
    if isinstance(type_object,ServiceFactoryType):
        if type_object.is_tvar and (not force_single_threaded):
            return 'AtomicServiceFactoryVariable'
        return 'NonAtomicServiceFactoryVariable'

    # emit for service references
    if isinstance(type_object,ServiceReferenceType):
        if type_object.is_tvar and (not force_single_threaded):
            return 'AtomicServiceReferenceVariable'
        return 'NonAtomicServiceReferenceVariable'
    
    # emit for others
    if isinstance(type_object,BasicType):
        typer = type_object.basic_type
        is_tvar = type_object.is_tvar
    elif isinstance(type_object,MethodType):
        typer = type_object.returns_type
        is_tvar = False
        
    if typer == BOOL_TYPE:
        if is_tvar and (not force_single_threaded):
            return 'AtomicTrueFalseVariable'
        return 'NonAtomicTrueFalseVariable'
    elif typer == NUMBER_TYPE:
        if is_tvar and (not force_single_threaded):
            return 'AtomicNumberVariable'
        return 'NonAtomicNumberVariable'        
    elif typer == STRING_TYPE:
        if is_tvar and (not force_single_threaded):
            return 'AtomicTextVariable'
        return 'NonAtomicTextVariable'

    raise InternalEmitException(
        'unknown',0,
        'Unknown type to emit in emit_ralph_wrapped_type')


def construct_new_expression(type_object,initializer_node,emit_ctx):
    """Generates the java new expression that assign a newly-declared
    variable to.

    Args:
        type_object: {BasicType object}
        
        initializer_node: {None or AstNode} What to assign with new
        expression.  If initializer node has null_type, then will be
        initialized to null.  If initializer_node is None, then
        initializes to default value.

        emit_ctx: {EmitContext}

    Returns:
        {string} --- Java-ized expression used on rhs of equals during
        declaration.
    """
    if isinstance(type_object,BasicType):
        initializer_text = None
        if initializer_node is not None:
            initializer_text = emit_statement(emit_ctx,initializer_node)
            
        java_type_text = emit_ralph_wrapped_type(type_object)
        if initializer_text is None:
            return 'new %s (false,ralph_globals)' % java_type_text
        return 'new %s (false,%s,ralph_globals)' % (java_type_text,initializer_text)
    elif isinstance(type_object,MapType):
        java_type_text = emit_ralph_wrapped_type(type_object)

        # FIXME: currently, disallowing initializing maps
        if initializer_node is not None:
            if initializer_node.label != NULL_TYPE:
                raise InternalEmitException(
                    initializer_node.filename,
                    initializer_node.line_number,
                    'Not handling initializers for map types')
            
        internal_map_version_helper = (
            internal_map_version_helper_from_map_type(type_object))
        
        # require EnsureAtomicWrapper object to 
        value_type_is_tvar = type_object.to_type_node.type.is_tvar
        value_type = type_object.to_type_node.type
        key_type = type_object.from_type_node.type
        value_type_wrapper = list_map_wrappers(value_type)

        key_type_class = class_from_element_type(key_type)
        value_type_class = class_from_element_type(value_type)

        internal_val_txt = ''
        if initializer_node is not None:
            # internal val should be null. note comma at end of
            # statement means that we do not include comma in
            # initializer.
            internal_val_txt = 'null,'

        to_return = '''
new %(java_type_text)s  (
    false,
    %(internal_val_text)s  
    %(value_type_wrapper)s,
    %(internal_map_version_helper)s,
    %(key_type_class)s,
    %(value_type_class)s,ralph_globals)
''' % { 'java_type_text': java_type_text,
        'internal_val_text': internal_val_txt,
        'value_type_wrapper': value_type_wrapper,
        'key_type_class': key_type_class,
        'value_type_class': value_type_class,
        'internal_map_version_helper': internal_map_version_helper}
        
        return to_return

    elif isinstance(type_object,ListType):
        java_type_text = emit_ralph_wrapped_type(type_object)

        # FIXME: currently, disallowing initializing lists
        if initializer_node is not None:
            if initializer_node.label != NULL_TYPE:
                raise InternalEmitException(
                    initializer_node.filename,
                    initializer_node.line_number,                    
                    'Not handling initializers for list types')
        
        # require EnsureAtomicWrapper object to 
        element_type = type_object.element_type_node.type
        element_type_class = class_from_element_type(element_type)
        element_type_wrapper = list_map_wrappers(element_type)
        
        internal_val_txt = ''
        if initializer_node is not None:
            # internal val should be null
            internal_val_txt = 'null,'
            
        to_return = (
            'new %s(false,%s%s,%s,ralph_globals)' %
            (java_type_text,internal_val_txt,element_type_wrapper,
             element_type_class))
        return to_return
    
    elif isinstance(type_object,StructType):
        struct_name = type_object.struct_name
        if initializer_node is not None:
            initializer_text = emit_statement(emit_ctx,initializer_node)
            to_return = (
                'new  %s(false,%s,ralph_globals)' % (struct_name,initializer_text))
        else:
            to_return = (
                'new  %s(false,ralph_globals)' % struct_name)

        return to_return
    
    elif isinstance(type_object,EndpointType):
        java_type_text = emit_ralph_wrapped_type(type_object)
        if initializer_node is not None:
            initializer_text = emit_statement(emit_ctx,initializer_node)
            to_return = (
                'new  %s(false,%s,ralph_globals)' % (java_type_text,initializer_text))
        else:
            default_internal_endpoint_text = (
                'new %s (ralph_globals,new SingleSideConnection())' %
                type_object.alias_name)
            
            to_return = (
                'new  %s(false,%s,ralph_globals)' %
                (java_type_text,default_internal_endpoint_text))
            

        return to_return

    elif isinstance(type_object,ServiceFactoryType):
        java_type_text = emit_ralph_wrapped_type(type_object)
        if initializer_node is not None:
            initializer_text = emit_statement(emit_ctx,initializer_node)
            to_return = (
                'new  %s(false,%s,ralph_globals)' % (java_type_text,initializer_text))
        else:
            to_return = (
                'new  %s(false,ralph_globals)' % java_type_text)

        return to_return

    elif isinstance(type_object,ServiceReferenceType):
        java_type_text = emit_ralph_wrapped_type(type_object)
        if initializer_node is not None:
            initializer_text = emit_statement(emit_ctx,initializer_node)
            to_return = (
                'new  %s(false,%s,ralph_globals)' % (java_type_text,initializer_text))
        else:
            to_return = (
                'new  %s(false,ralph_globals)' % java_type_text)

        return to_return

    elif isinstance(type_object,EnumType):
        java_type_text = emit_ralph_wrapped_type(type_object)
        enum_constructor_obj_name = emit_fully_qualified_enum_constructor_obj_name(
            type_object)
        enum_version_helper_obj_name = emit_fully_qualified_enum_version_helper_singleton_name(
            type_object)
        
        if initializer_node is not None:
            initializer_text = emit_statement(emit_ctx,initializer_node)
            to_return = ('''
new  %(java_type_text)s(
    false,%(initializer_text)s, %(enum_constructor_obj_name)s,
    %(enum_version_helper_obj_name)s, ralph_globals)'''
                         % {'java_type_text': java_type_text,
                            'initializer_text': initializer_text,
                            'enum_constructor_obj_name': enum_constructor_obj_name,
                            'enum_version_helper_obj_name': enum_version_helper_obj_name})
        else:
            to_return = ('''
new %(java_type_text)s(
    false,%(enum_constructor_obj_name)s, %(enum_version_helper_obj_name)s,
    ralph_globals)'''
                         % {'java_type_text': java_type_text,
                            'enum_constructor_obj_name': enum_constructor_obj_name,
                            'enum_version_helper_obj_name': enum_version_helper_obj_name})
        return to_return
    
    #### DEBUG
    else:
        raise InternalEmitException(
            'unknown',0,
            'Can only construct new expression from basic, map, or struct type')
    #### END DEBUG    


def internal_map_version_helper_from_map_type(map_type):
    '''
    @param {TypeObject} map_type --- Type of map.
    
    @returns{string} --- internal version helper associated with
    internal map with given index type.
    '''
    index_basic_type = map_type.from_type_node.type.basic_type
    if index_basic_type == NUMBER_TYPE:
        internal_map_version_helper = (
            'ralph.BaseTypeVersionHelpers.' +
            'DOUBLE_KEYED_INTERNAL_MAP_TYPE_VERSION_HELPER')
    elif index_basic_type == STRING_TYPE:
        internal_map_version_helper = (
            'ralph.BaseTypeVersionHelpers.' +
            'STRING_KEYED_INTERNAL_MAP_TYPE_VERSION_HELPER')
    elif index_basic_type == BOOL_TYPE:
        internal_map_version_helper = (
            'ralph.BaseTypeVersionHelpers.' +
            'BOOLEAN_KEYED_INTERNAL_MAP_TYPE_VERSION_HELPER')
    #### DEBUG
    else:
        raise InternalEmitException(
            'Unknown',0,
            'Map only accepts value types for indices')
    #### END DEBUG
    
    return internal_map_version_helper

    
def class_from_element_type(element_type):
    '''
    @param {TypeObject} element_type
    
    When constructing lists or maps, we need to pass in the class
    object associated with the list's/map's parameterized type.  For
    instance, for

    List<Double>, we'd want to pass in java.lang.Double.class so that
    versioning can log type of object we are versioning as well as the
    contents of that object.
    '''
    if isinstance(element_type,BasicType):
        element_basic_type = element_type.basic_type
        if element_basic_type == NUMBER_TYPE:
            return 'java.lang.Double.class'
        elif element_basic_type == STRING_TYPE:
            return 'java.lang.String.class'
        elif element_basic_type == BOOL_TYPE:
            return 'java.lang.Boolean.class'
        #### DEBUG
        else:
            raise InternalEmitException('unknown',0,'Unknown basic type.')
        #### END DEBUG
    elif isinstance(element_type,StructType):
        internal_struct_name = emit_internal_struct_type(element_type)        
        return internal_struct_name + '.class'
    elif isinstance(element_type,EnumType):
        return emit_internal_enum_type(element_type) + '.class'
    else:
        # FIXME: Currently disallowing containers holding elements to
        # anything beyond number, string, boolean, or struct types.
        raise InternalEmitException(
            'unknown',0,
            'FIXME: Still need to emit wrappers for non-basic value types.')
    
def list_map_wrappers(element_type):
    '''The type object of a list's elements or a map's values.
    '''
    element_type_is_tvar = element_type.is_tvar
    if isinstance(element_type,BasicType):
        element_basic_type = element_type.basic_type
        if element_basic_type == NUMBER_TYPE:
            element_type_wrapper = 'NUMBER_WRAPPER'
        elif element_basic_type == STRING_TYPE:
            element_type_wrapper = 'TEXT_WRAPPER'
        elif element_basic_type == BOOL_TYPE:
            element_type_wrapper = 'TRUE_FALSE_WRAPPER'
        #### DEBUG
        else:
            raise InternalEmitException('unknown',0,'Unknown basic type.')
        #### END DEBUG
        if not element_type_is_tvar:
            element_type_wrapper = 'NON_ATOMIC_' + element_type_wrapper
        else:
            element_type_wrapper = 'ATOMIC_' + element_type_wrapper
        element_type_wrapper = 'BaseAtomicWrappers.' + element_type_wrapper

    elif isinstance(element_type,StructType):
        element_type_wrapper = emit_struct_locked_map_wrapper_name(
            element_type)
    elif isinstance(element_type,EnumType):
        element_type_wrapper = (
            element_type.get_emit_name() + '.' +
            emit_enum_locked_map_wrapper_name(element_type))
    else:
        # FIXME: Need to emit wrappers for non-struct/non-basic
        # types.  (Eg., map types, list types.)
        raise InternalEmitException(
            'unknown',0,
            'FIXME: Still need to emit wrappers for non-basic value types.')

    return element_type_wrapper

    
def emit_internal_map_type(type_object):
    key_type_node = type_object.from_type_node
    value_type_node = type_object.to_type_node

    key_internal_type_text = emit_internal_type(
        key_type_node.type)
    value_internal_type_text = emit_internal_type(
        value_type_node.type)

    delta_value_internal_type_text = value_internal_type_text
    if isinstance(value_type_node.type,StructType):
        delta_value_internal_type_text = 'IReference'
    
    if type_object.is_tvar:
        internal_map_var_type = 'AtomicInternalMap'
    else:
        internal_map_var_type = 'NonAtomicInternalMap'
        
    return (
        internal_map_var_type +
        ('<%s,%s,%s>' %
         (key_internal_type_text,value_internal_type_text,
          delta_value_internal_type_text)))

def emit_internal_list_type(type_object):
    element_type_node = type_object.element_type_node
    element_type_text = emit_internal_type(
        element_type_node.type)

    if type_object.is_tvar:
        internal_map_var_type = 'AtomicInternalList'
    else:
        internal_map_var_type = 'NonAtomicInternalList'

    delta_element_type_text = element_type_text
    if isinstance(element_type_node.type,StructType):
        delta_element_type_text = 'IReference'
        
    return (
        internal_map_var_type +
        ('<%s,%s>' % (element_type_text,delta_element_type_text)))


def emit_map_type(type_object):
    # emit for maps
    if isinstance(type_object,MapType):
        key_type_node = type_object.from_type_node
        value_type_node = type_object.to_type_node

        key_internal_type_text = emit_internal_type(
            key_type_node.type)
        value_internal_type_text = emit_internal_type(
            value_type_node.type)


        map_var_type = 'NonAtomicMapVariable'
        if type_object.is_tvar:
            map_var_type = 'AtomicMapVariable'

        delta_value_internal_type_text = value_internal_type_text
        if isinstance(value_type_node.type,StructType):
            delta_value_internal_type_text = 'IReference'
            
        # FIXME: May not be dewaldo-ifying maps correctly
        to_return = (
            '%s<%s,%s,%s>' %
            (map_var_type,key_internal_type_text,
             value_internal_type_text,delta_value_internal_type_text))

        return to_return
    else:
        raise InternalEmitException(
            'unknown',0,
            'Requires map type in emit_map_type')

    
def emit_list_type(type_object):
    # emit for lists
    if isinstance(type_object,ListType):
        element_type_node = type_object.element_type_node
        element_internal_type_text = emit_internal_type(
            element_type_node.type)

        delta_element_internal_type_text = element_internal_type_text
        if isinstance(element_type_node.type,StructType):
            delta_element_internal_type_text = 'IReference'

        
        list_var_type = 'NonAtomicListVariable'
        if type_object.is_tvar:
            list_var_type = 'AtomicListVariable'

        to_return = (
            '%s<%s,%s>' %
            (list_var_type,element_internal_type_text,
             delta_element_internal_type_text))

        return to_return
    else:
        raise InternalEmitException(
            'unknown',0,
            'Requires list type in emit_list_type')

def emit_internal_type(type_object):
    '''
    @param {Type or None} type_object --- None if type corresponds to
    void (eg., in method signature).

    @returns{String} --- Java-ized version of Ralph type: eg.,
    Double, Boolean, etc.
    '''
    if type_object is None:
        return 'void'
    else:
        # emit for map type
        if isinstance(type_object,MapType):
            return emit_internal_map_type(type_object)

        # emit for list type
        if isinstance(type_object,ListType):
            return emit_internal_list_type(type_object)
        
        # emit for struct type
        if isinstance(type_object,StructType):
            return emit_internal_struct_type(type_object)

        # emit for endpoints
        if isinstance(type_object,EndpointType):
            return type_object.alias_name

        # emit for enums
        if isinstance(type_object,EnumType):
            return emit_internal_enum_type(type_object)

        
        # emit for ServiceFactories
        if isinstance(type_object,ServiceFactoryType):
            return 'InternalServiceFactory'
        # emit for ServiceReference
        if isinstance(type_object,ServiceReferenceType):
            return 'InternalServiceReference'
        
        # emit for basic types
        if isinstance(type_object,BasicType):
            typer = type_object.basic_type
        elif isinstance(type_object,MethodType):
            typer = type_object.returns_type
            if typer is not None:
                # FIXME: Ugly, hackish way to return lists
                if isinstance(typer,ListType):
                    return emit_internal_type(typer)
                # FIXME: Ugly, hackish way to return maps
                if isinstance(typer,MapType):
                    return emit_internal_type(typer)
                # FIXME: Ugly, hackish way to return structs
                if isinstance(typer,StructType):
                    return emit_internal_type(typer)
                # FIXME: Ugly, hackish way to return endpoints
                if isinstance(typer,EndpointType):
                    return emit_internal_type(typer)
                # FIXME: Ugly, hackish way to return service factories
                if isinstance(typer,ServiceFactoryType):
                    return emit_internal_type(typer)
                # FIXME: Ugly, hackish way to return service references
                if isinstance(typer,ServiceReferenceType):
                    return emit_internal_type(typer)
                # FIXME: Ugly, hackish way to return enums
                if isinstance(typer,EnumType):
                    return emit_internal_type(typer)
                
                # FIXME: Need to support returning ServiceFactories,
                # Services, and ServiceReferenceType
                typer = typer.basic_type
                
        if typer == BOOL_TYPE:
            return 'Boolean'
        elif typer == NUMBER_TYPE:
            return 'Double'
        elif typer == STRING_TYPE:
            return 'String'
        elif typer is None:
            return 'void'

    raise InternalEmitException(
        'unknown',0,'Unknown type in emit_internal_type')

# indices are labels; values are operators should compile to.
NUMERICAL_ONLY_BINARY_LABELS_DICT = {
    ast_labels.SUBTRACT: '-',
    ast_labels.MULTIPLY: '*',
    ast_labels.DIVIDE: '/'
    }
NUMERICAL_ONLY_COMPARISONS_DICT = {
    ast_labels.GREATER_THAN: '>',
    ast_labels.GREATER_THAN_EQUALS: '>=',
    ast_labels.LESS_THAN: '<',
    ast_labels.LESS_THAN_EQUALS: '<='
    }

def is_text_node(ast_node):
    '''
    @returns {boolean} --- True if ast_node has text type, false
    otherwise.
    '''
    if isinstance(ast_node.type,BasicType):
        basic_type = ast_node.type.basic_type
        if basic_type == STRING_TYPE:
            return True
    return False

def emit_statement(emit_ctx,statement_node):
    '''
    @param {EmitContext} emit_ctx --- Already loaded with previous
    scopes' variables, including method arguments.

    @param {AstNode} statement_node --- Can be any ast node that is
    classified as a statement in the parsing rules
    '''
    if statement_node.label in NUMERICAL_ONLY_BINARY_LABELS_DICT:
        lhs = emit_statement(emit_ctx,statement_node.lhs_expression_node)
        rhs = emit_statement(emit_ctx,statement_node.rhs_expression_node)
        
        java_operator = NUMERICAL_ONLY_BINARY_LABELS_DICT[statement_node.label]
        return (
            '(new Double(%s.doubleValue() %s %s.doubleValue() ) )' %
            (lhs, java_operator, rhs))

    elif statement_node.label == ast_labels.ADD:
        # add can be a string or a number.  It will return a string if
        # either the lhs or the rhs are strings.  Otherwise, it'll
        # return a number.
        lhs = emit_statement(emit_ctx,statement_node.lhs_expression_node)
        rhs = emit_statement(emit_ctx,statement_node.rhs_expression_node)

        string_addition = False
        # check if lhs is string
        if (is_text_node(statement_node.lhs_expression_node) or
            is_text_node(statement_node.rhs_expression_node)):
            string_addition = True

        if not string_addition:
            return (
                '(new Double(%s.doubleValue() + %s.doubleValue() ) )' %
                (lhs, rhs))

        return (
            '(new String(%s.toString() + %s.toString() ) )' %
            (lhs, rhs))
    
    elif statement_node.label == ast_labels.NUMBER_LITERAL:
        return '(new Double(%f))' % statement_node.value

    elif statement_node.label == ast_labels.TO_TEXT_CALL:
        to_text_arg_statement = (
            emit_statement(emit_ctx,statement_node.to_text_arg_node))
        return '(%s).toString()' % to_text_arg_statement
    
    elif statement_node.label == ast_labels.NOT:
        to_not_text = emit_statement(emit_ctx,statement_node.to_not_node)
        return '(new Boolean( ! %s.booleanValue()))' % to_not_text

    elif statement_node.label == ast_labels.AND:
        lhs = emit_statement(emit_ctx,statement_node.lhs_expression_node)
        rhs = emit_statement(emit_ctx,statement_node.rhs_expression_node)
        return (
            '(new Boolean( %s.booleanValue() && %s.booleanValue()))' %
            (lhs,rhs))
    elif statement_node.label == ast_labels.OR:
        lhs = emit_statement(emit_ctx,statement_node.lhs_expression_node)
        rhs = emit_statement(emit_ctx,statement_node.rhs_expression_node)
        return (
            '(new Boolean( %s.booleanValue() || %s.booleanValue()))' %
            (lhs,rhs))

    elif statement_node.label == ast_labels.PRINT_CALL:
        print_arg_statement = emit_statement(emit_ctx,statement_node.print_arg_node)
        return 'System.out.print(%s)' % print_arg_statement

    elif statement_node.label in [ast_labels.SPECULATE_CALL,
                                  ast_labels.SPECULATE_CONTAINER_INTERNALS_CALL]:
        to_return = ''

        # If the call is just a specualte call (not specualte
        # container internals), then we speculate on just the wrapper
        # of an object.  For instance, for the following code
        #
        #    List(element: Number) some_list;
        #    List(element: Number) some_other_list;
        #        ...
        #    some_list = some_other_list;
        #    speculate(some_list);
        #
        # Allows other events to now read/write on top of
        # some_other_list when accessing some_list.
        #
        # However, 
        #
        #    List(element: Number) some_list;
        #    some_list.append(1);
        #    speculate(some_list);
        #
        # does not allow other events to perform basic operations.
        # Eg.,
        #
        #    some_list.size();
        #
        # This is because speculate allows us to speculate on the pointer
        # wrapping the internal list, we cannot speculate on the
        # contents of that internal list.
        #
        # To speculate on the internal value instead, use
        #
        #    speculate_container_internals(some_list);
        #
        # This method should get the internal container pointed at and
        # call speculate on it, instead of the external wrapper.
        # Hence, in code below, if calling
        # SPECULATE_CONTAINER_INTERNALS_CALL, then first get value of
        # internal container.
        suffix_to_speculate_on = ''
        if statement_node.label == ast_labels.SPECULATE_CONTAINER_INTERNALS_CALL:
            suffix_to_speculate_on = '.get_val(_active_event)'

        prev_lhs_of_assign = emit_ctx.get_lhs_of_assign()
        emit_ctx.set_lhs_of_assign(True)
        for to_speculate_on in statement_node.speculate_call_args_list:
            emitted_to_speculate_on = emit_statement(emit_ctx,to_speculate_on)
            to_return += (
                '%s%s.speculate(_active_event);\n' %
                (emitted_to_speculate_on,suffix_to_speculate_on))
        emit_ctx.set_lhs_of_assign(prev_lhs_of_assign)
        return to_return
        
    elif statement_node.label == ast_labels.SPECULATE_ALL_CALL:
        raise InternalEmitException(
            statement_node.filename,
            statement_node.line_number,
            'FIXME: still must allow speculate_all call')

    elif statement_node.label == ast_labels.BREAK:
        return 'break'

    elif statement_node.label == ast_labels.RANGE:
        start_expression_text = emit_statement(
            emit_ctx,statement_node.start_expression_node)
        increment_expression_text = emit_statement(
            emit_ctx,statement_node.increment_expression_node)
        end_expression_text = emit_statement(
            emit_ctx,statement_node.end_expression_node)

        return (
            'this._produce_range(%s,%s,%s)' %
            (start_expression_text,end_expression_text,
             increment_expression_text))
    
    elif statement_node.label == ast_labels.CONTINUE:
        return 'continue'
    
    elif statement_node.label == ast_labels.VERBATIM_CALL:
        return statement_node.verbatim_arg_node.value.replace('\\n','\n')

    elif statement_node.label == ast_labels.SELF:
        return '(this)' 
    
    elif statement_node.label == ast_labels.EQUALS:
        lhs_node = statement_node.lhs_expression_node
        rhs_node = statement_node.rhs_expression_node
        
        lhs = emit_statement(emit_ctx, statement_node.lhs_expression_node)
        rhs = emit_statement(emit_ctx, statement_node.rhs_expression_node)
        if ((lhs_node.label == NULL_TYPE) or
            (rhs_node.label == NULL_TYPE)):
            return '(new Boolean(%s == %s))' % (lhs,rhs)
        return ('(new Boolean(%s == null ? %s == %s : %s.equals(%s)))' %
                (lhs,lhs,rhs,lhs,rhs))

    elif statement_node.label == ast_labels.NOT_EQUALS:
        lhs_node = statement_node.lhs_expression_node
        rhs_node = statement_node.rhs_expression_node
        
        lhs = emit_statement(emit_ctx, statement_node.lhs_expression_node)
        rhs = emit_statement(emit_ctx, statement_node.rhs_expression_node)
        if ((lhs_node.label == NULL_TYPE) or
            (rhs_node.label == NULL_TYPE)):
            return '(new Boolean(%s != %s))' % (lhs,rhs)
        return ('(new Boolean(! (%s == null ? %s == %s : %s.equals(%s))))'
                % (lhs,lhs,rhs,lhs,rhs))
    
    elif statement_node.label == ast_labels.ATOMICALLY:
        atomic_logic = ''
        for statement in statement_node.statement_list:
            atomic_logic += emit_statement(emit_ctx,statement)
            atomic_logic += emit_semicolon_line_break(statement)

        atomic_logic = indent_string(atomic_logic,2)
        
        return '''
{
    // atomically clause
    while(true)
    {
        _active_event = _active_event.clone_atomic();

        // what to actually execute inside of atomic block
        try
        {
%s
        }
        catch (BackoutException _be)
        {
            _active_event.handle_backout_exception(_be);
        }
        finally
        {
        }

        // FIXME: may want to mangle this further
        FirstPhaseCommitResponseCode __ralph_internal_resp_code =
            _active_event.local_root_begin_first_phase_commit();

        if (__ralph_internal_resp_code == FirstPhaseCommitResponseCode.SKIP)
            break;
        else if (__ralph_internal_resp_code == FirstPhaseCommitResponseCode.SUCCEEDED)
        {
            // means that the call to 
            try {

                // FIXME: should properly mangle __op_result__
                RootCallResult.ResultType __op_result__ =
                    ((RootEventParent)_active_event.event_parent).event_complete_queue.take();

                if (__op_result__ == RootCallResult.ResultType.COMPLETE)
                    break;
            } catch (InterruptedException _ex) {
                // TODO Auto-generated catch block
                // FIXME: handle InterruptedException?
                _ex.printStackTrace();
            }
        }

        // if got here, means that this was the first atomic statement and it failed so
        // we must retry: restore to previous nonatomicactiveevent and clone again
        _active_event = _active_event.restore_from_atomic();
    }
    _active_event = _active_event.restore_from_atomic();
}
''' % atomic_logic

    elif statement_node.label == ast_labels.ASSIGNMENT:
        rhs_text = emit_statement(emit_ctx,statement_node.rhs_node)
        emit_ctx.set_lhs_of_assign(True)
        lhs_text = emit_statement(emit_ctx,statement_node.lhs_node)
        emit_ctx.set_lhs_of_assign(False)

        # FIXME: special-casing handling setting from partner method
        # call.  The reason that we're doing this is because we might
        # get a null value from rpcs that do not return anything.
        is_partner_method_call = False
        if statement_node.rhs_node.label == ast_labels.PARTNER_METHOD_CALL:
            is_partner_method_call = True
            get_val_text = '.get_val(_active_event)'

        if not is_partner_method_call:
            return (
                '%s.set_val(_active_event,%s);\n' % (lhs_text,rhs_text));
        
        internal_type = emit_internal_type(statement_node.lhs_node.type)
        return (
            '%s.set_val(_active_event,(%s)%s.get_val(_active_event));\n' %
            (lhs_text,internal_type,rhs_text));

    elif statement_node.label == ast_labels.IDENTIFIER_EXPRESSION:

        # first, check if call is a method.  if it is, then just emit
        # it directly.
        if isinstance(statement_node.type,MethodType):
            # check if global method or local method
            if emit_ctx.method_name_in_method_set(statement_node.value):
                # it is a global method: return the unaltered name
                # immediately.
                return statement_node.value
            else:
                return '/** Not yet supporting function objects.*/'


        # guaranteed that the identifier is for a non-method object type
        internal_var_name = emit_ctx.lookup_internal_var_name(
            statement_node.value)
        
        if internal_var_name is None:
            # internal_var_name is not declared in this scope: some
            # type of error.
            raise InternalEmitException(
                statement_node.filename,
                statement_node.line_number,
                'No record of variable named %s' % statement_node.value)

        if not emit_ctx.get_lhs_of_assign():
            # if not in lhs of assign, then actually get internal
            # value of variable.  (So can perform action on it.)
            if isinstance(statement_node.type,EndpointType):
                # must cast endpoint object to expected aliased
                # endpoint type so that can call its correct methods
                # on it.  
                aliased_endpoint_name = statement_node.type.alias_name
                internal_var_name = (
                    '((%s) %s.get_val(_active_event))' %
                    (aliased_endpoint_name, internal_var_name))
            else:
                internal_var_name += '.get_val(_active_event)'

        return internal_var_name

    elif statement_node.label == ast_labels.FOR:
        return emit_for_statement(statement_node,emit_ctx)
    elif statement_node.label == ast_labels.METHOD_CALL:
        # FIXME: Need to handle method calls on objects as well
        method_text = emit_statement(
            emit_ctx,
            # statement_node.method node is an identifier or dot node
            statement_node.method_node)

        # dot statements should only take in ExecutingEventContexts if
        # they are calls to endpoint objects.  Otherwise, they are
        # likely calls to map, list, etc., objects.  Calling .size on
        # a map should not call .get_len on internal map and pass in a
        # _ctx.  It should just pass in _active_event.
        if statement_node.method_node.label != ast_labels.DOT:
            method_text += '(_ctx,_active_event'
        else:
            
            if isinstance(statement_node.method_node.type,WildcardType):
                # means that calling dot on endpoint node
                method_text += '(_ctx,_active_event'
            else:
                # means that calling dot on map/list/etc.
                method_text += '(_active_event'

                
        for arg_node in statement_node.args_list:
            arg_text = emit_statement(emit_ctx,arg_node)
                
            method_text += ',' + arg_text
        method_text += ')'
        return method_text


    elif statement_node.label == ast_labels.PARTNER_METHOD_CALL:
        rpc_args = []

        # FIXME: only allowing putting identifiers into arguments of
        # remote method call because must create RPC arguments
        prev_lhs_of_assign = emit_ctx.get_lhs_of_assign()
        emit_ctx.set_lhs_of_assign(True)
        for rpc_arg_node in statement_node.args_list:

            # FIXME: Setting false here, which disallows sending arg
            # as reference.
            rpc_arg_text = emit_statement(emit_ctx,rpc_arg_node)
            rpc_args.append(rpc_arg_text)
        emit_ctx.set_lhs_of_assign(prev_lhs_of_assign)

        array_list_arg = ''
        if len(rpc_args) != 0:
            array_list_arg = 'Arrays.asList(%s)' % ','.join(rpc_args)
            
        rpc_args_list_text = (
            'new ArrayList<RalphObject>( %s)' % array_list_arg)

        partner_call_text = '''
_ctx.hide_partner_call(
    this, _active_event,"%s",true, //whether or not first method call
    %s,null)''' %  ( statement_node.partner_method_name, rpc_args_list_text)

        return partner_call_text
    
    elif statement_node.label in NUMERICAL_ONLY_COMPARISONS_DICT:
        lhs = emit_statement(emit_ctx, statement_node.lhs_expression_node)
        rhs = emit_statement(emit_ctx, statement_node.rhs_expression_node)
        comparison = NUMERICAL_ONLY_COMPARISONS_DICT[statement_node.label]
        return (
            '(new Boolean(%s.doubleValue() %s %s.doubleValue()))' %
            (lhs,comparison,rhs))

    elif statement_node.label == ast_labels.TRUE_FALSE_LITERAL:
        internal = 'false'
        if statement_node.value:
            internal = 'true'
        return '(new Boolean(%s))' % internal

    elif statement_node.label == ast_labels.TEXT_LITERAL:
        return '("' + statement_node.value + '")'
    
    elif statement_node.label == ast_labels.DECLARATION_STATEMENT:
        java_type_statement = emit_ralph_wrapped_type(statement_node.type)
        new_expression = construct_new_expression(
            statement_node.type,statement_node.initializer_node,emit_ctx)

        # add new variable to emit_ctx stack
        emit_ctx.add_var_name(statement_node.var_name)
        internal_var_name = emit_ctx.lookup_internal_var_name(
            statement_node.var_name)

        declaration_statement = (
            '%s %s = %s; ' %
            (java_type_statement,internal_var_name,new_expression))

        if emit_ctx.get_in_endpoint_global_vars():
            declaration_statement = 'private ' + declaration_statement
            
        return declaration_statement + '\n'

    elif statement_node.label == ast_labels.RETURN:
        return_text = 'return'
        if statement_node.what_to_return_node is not None:
            return_text += ' ' + emit_statement(
                emit_ctx,statement_node.what_to_return_node)
        return return_text
    
    elif statement_node.label == ast_labels.CONDITION:

        if_text = emit_statement(emit_ctx,statement_node.if_node)
        elif_text = '\n'
        for elif_node in statement_node.elifs_list:
            elif_text += emit_statement(emit_ctx,elif_node)
            elif_text += '\n'
        else_text = ''
        if statement_node.else_node_body is not None:
            else_text = 'else {\n'
            else_text_body = emit_statement(emit_ctx,statement_node.else_node_body)
            else_text_body += emit_semicolon_line_break(statement_node.else_node_body)
            else_text += indent_string(else_text_body)
            else_text += '\n}\n'

        return if_text + elif_text + else_text

    elif statement_node.label == ast_labels.IF:
        predicate_text = emit_statement(emit_ctx,statement_node.predicate_node)
        if_text = 'if (%s.booleanValue()){\n' % predicate_text
        if_body_text = emit_statement(emit_ctx,statement_node.body_node)
        if_body_text += emit_semicolon_line_break(statement_node.body_node)
        if_text += indent_string(if_body_text) + '\n}\n'
        return if_text

    elif statement_node.label == ast_labels.ELIF:
        predicate_text = emit_statement(emit_ctx,statement_node.predicate_node)
        elif_text = 'else if (%s.booleanValue()){\n' % predicate_text
        elif_body_text = emit_statement(emit_ctx,statement_node.body_node)
        elif_body_text += emit_semicolon_line_break(statement_node.body_node)
        elif_text += indent_string(elif_body_text) + '\n}\n'
        return elif_text
    
    elif statement_node.label == ast_labels.SCOPE:
        to_return = '{\n'

        scope_body_text = 'try \n {\n'
        
        # Any variable declared in this scope should be removed after
        # this scope statement: so push on a scope to emit_ctx and
        # after emitting individual statements (ie, at end of for
        # loop, pop off of emit_ctx).
        emit_ctx.push_scope()
        for individual_statement_node in statement_node.statement_list:
            scope_body_text += indent_string(
                emit_statement(emit_ctx,individual_statement_node))
            scope_body_text += emit_semicolon_line_break(
                individual_statement_node)

        emit_ctx.pop_scope()

        scope_body_text +='}\n'
        scope_body_text += 'finally {}\n'
        to_return += indent_string(scope_body_text) + '\n}\n'
        
        return to_return

    elif statement_node.label == ast_labels.DOT:
        return emit_dot_statement(emit_ctx,statement_node)

    elif statement_node.label == ast_labels.NULL_TYPE:
        return 'null'

    elif statement_node.label == ast_labels.DYNAMIC_CAST:
        what_casting_node = statement_node.cast_arg_node
        what_casting_text = emit_statement(emit_ctx,what_casting_node)
        
        casting_to_variable_type_node = statement_node.to_variable_type_node
        casting_to_type_text = emit_internal_type(
            casting_to_variable_type_node.type)
        
        return '((%s) %s)' % (casting_to_type_text,what_casting_text)
    
    return (
        '\n/** FIXME: must fill in emit_method_body for label %s */\n' %
        statement_node.label)


def emit_dot_statement(emit_ctx,dot_node):
    """
    """
    left_of_dot_node = dot_node.left_of_dot_node
    right_of_dot_node = dot_node.right_of_dot_node

    if isinstance(dot_node.type,EnumType):
        # enums can have their fields accessed using dot.  Eg., for
        # enum Day { MONDAY, TUESDAY, ... }
        # Day.MONDAY is valid syntax

        # however, a struct with an enum field will have the same dot
        # structure.  We distinguish between references to these two
        # in the following way: if the left of dot node is an
        # identifier and it appears in the 
        if left_of_dot_node.label == ast_labels.IDENTIFIER_EXPRESSION:
            left_value = left_of_dot_node.get_value()
            enum_type = (
                emit_ctx.struct_types_ctx.get_enum_type_obj_from_enum_name(
                    left_value))
            if enum_type is not None:
                # means that the left hand side of the dot was a
                # declared enum type.  Eg., for
                # enum Day { MONDAY, TUESDAY, ...}
                # it was Day.
                # in this case, left_of_dot_node and right_of_dot_node
                # should both be identifiers
                enum_field_name = right_of_dot_node.get_value()
                return dot_node.type.get_emit_name() + '.' + enum_field_name
    
    to_return = emit_statement(emit_ctx,left_of_dot_node)
    if isinstance(left_of_dot_node.type,MapType):
        if right_of_dot_node.label != ast_labels.IDENTIFIER_EXPRESSION:
            raise InternalEmitException(
                right_of_dot_node.filename,
                right_of_dot_node.line_number,
                'Expected identifier to the right of %s' %
                statement_node.value)
        right_hand_side_method = right_of_dot_node.value
        if right_hand_side_method == MapType.SIZE_METHOD_NAME:
            to_return += '.get_len_boxed'
        elif right_hand_side_method == MapType.CONTAINS_METHOD_NAME:
            to_return += '.contains_key_called_boxed'
        elif right_hand_side_method == MapType.GET_METHOD_NAME:
            to_return += '.get_val_on_key'
        elif right_hand_side_method == MapType.SET_METHOD_NAME:
            to_return += '.set_val_on_key'
        elif right_hand_side_method == MapType.REMOVE_METHOD_NAME:
            to_return += '.remove'
        elif right_hand_side_method == MapType.CLEAR_METHOD_NAME:
            to_return += '.clear'            
        #### DEBUG
        else:
            raise InternalEmitException(
                right_of_dot_node.filename,
                right_of_dot_node.line_number,
                'Unknown identifier on rhs of dot for map.')
        #### END DEBUG
    elif isinstance(left_of_dot_node.type,ListType):
        if right_of_dot_node.label != ast_labels.IDENTIFIER_EXPRESSION:
            raise InternalEmitException(
                left_of_dot_node.filename,
                left_of_dot_node.line_number,
                'Expected identifier to the right of %s' %
                statement_node.value)
        right_hand_side_method = right_of_dot_node.value
        if right_hand_side_method == ListType.SIZE_METHOD_NAME:
            to_return += '.get_len_boxed'
        elif right_hand_side_method == ListType.CONTAINS_METHOD_NAME:
            to_return += '.contains_key_called_boxed'
        elif right_hand_side_method == ListType.GET_METHOD_NAME:
            to_return += '.get_val_on_key'
        elif right_hand_side_method == ListType.SET_METHOD_NAME:
            to_return += '.set_val_on_key'
        elif right_hand_side_method == ListType.APPEND_METHOD_NAME:
            to_return += '.append'
        elif right_hand_side_method == ListType.INSERT_METHOD_NAME:
            to_return += '.insert'
        elif right_hand_side_method == ListType.REMOVE_METHOD_NAME:
            to_return += '.remove'
        elif right_hand_side_method == ListType.CLEAR_METHOD_NAME:
            to_return += '.clear'
        #### DEBUG
        else:
            raise InternalEmitException(
                left_of_dot_node.filename,
                left_of_dot_node.line_number,
                'Unknown identifier on rhs of dot for map.')
        #### END DEBUG
    elif isinstance(left_of_dot_node.type,StructType):
        in_lhs_of_assign = emit_ctx.get_lhs_of_assign()
        # note that if we are assigning to a struct's internal fields,
        # then we should get the internal value of the struct so that
        # can access fields.
        if in_lhs_of_assign:
            to_return += '.get_val(_active_event)'

        if right_of_dot_node.label != ast_labels.IDENTIFIER_EXPRESSION:
            raise InternalEmitException(
                left_of_dot_node.filename,
                left_of_dot_node.line_number,
                'FIXME: Cannot handle accessing struct nested field beyond ' +
                'two layers.  Eg., a.b is fine, but a.b.c is not.')
        rhs_node_identifier_name = right_of_dot_node.value
        rhs_node_text = '.' + rhs_node_identifier_name
        if not in_lhs_of_assign:
            rhs_node_text += '.get_val(_active_event)'
        to_return += rhs_node_text

    elif isinstance(left_of_dot_node.type,EndpointType):
        right_hand_side_method = right_of_dot_node.value
        to_return += '.' + right_hand_side_method

    elif isinstance(left_of_dot_node.type,ServiceFactoryType):
        if right_of_dot_node.label != ast_labels.IDENTIFIER_EXPRESSION:
            raise InternalEmitException(
                left_of_dot_node.filename,
                left_of_dot_node.line_number,
                'Expected identifier to the right of %s' %
                statement_node.value)
        right_hand_side_method = right_of_dot_node.value
        if right_hand_side_method == ServiceFactoryType.CONSTRUCT_METHOD_NAME:
            to_return += '.construct'
        elif right_hand_side_method == ServiceFactoryType.CONSTRUCT_FROM_REFERENCE_METHOD_NAME:
            to_return += '.construct_from_reference'
        #### DEBUG
        else:
            raise InternalEmitException(
                left_of_dot_node.filename,
                left_of_dot_node.line_number,
                'Unknown identifier on rhs of dot for service factory.')
        #### END DEBUG
    else:
        raise InternalEmitException(
            dot_node.filename,
            dot_node.line_number,
            'Unknown dot statement: not dot on map or struct.')
        
    return to_return

def emit_for_loop_cast_line_list(
    internal_var_name_text,variable_type_node):
    '''
    cannot put ralph variables directly in predicate of for loop,
    because of casting issue with Java collections.  This takes a
    member of the collection and individually casts it to its
    appropriate value as the first line of the for loop for lists.
    Sister method emit_for_loop_cast_line_map does same thing,
    but for map keys.
    '''
    java_type_statement_text = emit_ralph_wrapped_type(
        variable_type_node.type)
    return (
        '%s %s = (%s) __%s;' %
        ( #lhs of =
            java_type_statement_text,internal_var_name_text,
            # rhs of =
            java_type_statement_text,internal_var_name_text))
def emit_for_loop_cast_line_map(
    internal_var_name_text,variable_type_node):
    '''
    @see emit_internal_for_statement_for_list
    
    Big difference between list and map is that map should hold a raw
    Java boxed value that needs to get wrapped in Ralph object
    '''
    java_type_statement_text = emit_ralph_wrapped_type(
        variable_type_node.type)
    internal_type = emit_internal_type(variable_type_node.type)
    return (
        '%s %s = new %s(false,(%s)__%s,ralph_globals); ' %
        (java_type_statement_text,internal_var_name_text,
         java_type_statement_text,internal_type,
         internal_var_name_text))

def emit_for_statement(for_node,emit_ctx):
    '''
    @returns {String}
    '''
    # first add a scope so that any variable decalred in the for
    # loop's predicate will only be local to the for loop.
    to_return = ''
    emit_ctx.push_scope()
    
    # add new variable to emit_ctx stack
    emit_ctx.add_var_name(for_node.variable_node.value)
    internal_var_name_text = emit_ctx.lookup_internal_var_name(
        for_node.variable_node.value)

    # predicate of for loop is different for lists and maps
    if isinstance(for_node.in_what_node.type,ListType):
        cast_line = emit_for_loop_cast_line_list(
            internal_var_name_text,for_node.variable_type_node)
    elif isinstance(for_node.in_what_node.type,MapType):
        cast_line = emit_for_loop_cast_line_map(
            internal_var_name_text,for_node.variable_type_node)
    else:
        raise InternalEmitException(
            for_node.filename,
            for_node.line_number,
            'Running for loop over non-map/-list is disallowed.')
        

    # identifier iterating over should not use its get_val (see
    # comments about assignment)
    in_statement_text = emit_statement(emit_ctx,for_node.in_what_node)
    # using for predicate because cannot perform cast of ArrayList<T>
    # to ArrayList<Y>.  Top of for loop casts __%s to %s.
    to_return += (
        'for (Object __%s : %s.get_iterable(_active_event))'
        % (internal_var_name_text,
           in_statement_text))

    # statement body
    statement_body_text = emit_statement(emit_ctx,for_node.statement_node)
    internal_statement_text = '''
// casting back from RalphObject to actual object that it holds.
// cannot perform cast in for predicate.
%s;
// for body
%s%s
'''  % (cast_line,        
        # for body
        statement_body_text,
        emit_semicolon_line_break(for_node.statement_node))
    
    to_return += '''
{
    try
    {
        %s
    }
    finally
    {
    }
}
''' % indent_string(internal_statement_text)
       
    emit_ctx.pop_scope()
    return to_return


######### HANDLING ENUMS ########
def emit_enum_definition(enum_name,enum_type,struct_ctx):
    
    # Only emit enums for this file.
    where_declared_enum = (
        struct_ctx.enum_ctx.get_decl_point_from_enum_name(enum_name))
    
    if struct_ctx.filename != where_declared_enum.filename:
        return ''

    to_return = ('''
public enum %(enum_name)s {''' % {'enum_name': enum_type.get_emit_name()})

    from_ordinal_body_text = ''
    for i in range(0,len(enum_type.field_list)):
        field_name = enum_type.field_list[i]
        to_return += field_name
        if i < len(enum_type.field_list) -1:
            to_return += ','
        else:
            to_return += ';'

        # emitting body text for from_ordinal
        from_ordinal_body_text += '''
if (ordinal == %(field_index)i)
    return %(field_name)s;
''' % { 'field_index': i,
        'field_name': field_name}

    to_return += indent_string('''
public static %(enum_name)s from_ordinal(int ordinal)
{
%(from_ordinal_body_text)s
    Util.logger_assert("Unknown ordinal to build enum from");
    return null;
}
''' % { 'from_ordinal_body_text': indent_string(from_ordinal_body_text),
        'enum_name': enum_type.get_emit_name()})

    to_return += indent_string(
        emit_enum_constructor_obj_and_instance(enum_type))
    to_return += indent_string(
        emit_enum_serializer_and_version_helper_singleton(enum_type))
    
    enum_version_helper_name = emit_enum_version_helper_singleton_name(enum_type)
    ### FIXME: kind of stupid that have to special case no logic for
    ### empty enums.
    if len(enum_type.field_list) != 0:
        # add a wrapper so that enum can be placed in list/map
        to_return += indent_string('''
private static class %(enum_class_name)s_wrapper_class
    implements EnsureAtomicWrapper<%(enum_class_name)s,%(enum_class_name)s>
{
    @Override
    public String get_serialization_label()
    {
        Util.logger_assert("Must wrap enums correctly.");
        return null;
    }
    @Override
    public RalphObject<%(enum_class_name)s,%(enum_class_name)s> ensure_atomic_object(
        %(enum_class_name)s object_to_ensure, RalphGlobals ralph_globals)
    {
        return new AtomicEnumVariable(
            false,object_to_ensure,%(enum_constructor_obj_name)s,
            %(enum_version_helper_name)s,ralph_globals);
    }
}

public final static %(enum_class_name)s_wrapper_class %(enum_locked_map_wrapper_name)s =
    new %(enum_class_name)s_wrapper_class();

    ''' % { 'enum_class_name': enum_type.get_emit_name(),
            'enum_locked_map_wrapper_name': emit_enum_locked_map_wrapper_name(enum_type),
            'enum_constructor_obj_name': emit_fully_qualified_enum_constructor_obj_name(enum_type),
            'enum_version_helper_name': enum_version_helper_name})

    # butting this under atomic wrapper because it depends on static
    # atomic wrapper var.
    to_return += indent_string(
        emit_enum_map_list_variable_factories(enum_type))
        
    to_return += '}'
    return to_return

def emit_internal_enum_type(enum_type):
    return enum_type.get_emit_name()

def emit_enum_constructor_class_name(enum_type):
    return enum_type.prepend_to_name('some__constructor_class_name')

def emit_fully_qualified_enum_constructor_class_name(enum_type):
    return (
        enum_type.get_emit_name() + '.' +
        emit_enum_constructor_class_name(enum_type))

def emit_fully_qualified_enum_constructor_obj_name(enum_type):
    return (
        enum_type.get_emit_name() + '.' +
        emit_enum_constructor_obj_name(enum_type))

def emit_enum_constructor_obj_name(enum_type):
    return 'enum_constructor_obj'

def emit_enum_version_helper_singleton_name(enum_type):
    return 'enum_version_helper_singleton'

def emit_fully_qualified_enum_version_helper_singleton_name(enum_type):
    return (
        enum_type.get_emit_name() + '.' +
        emit_enum_version_helper_singleton_name(enum_type))

def emit_enum_serializer_and_version_helper_singleton(enum_type):
    singleton_obj_name = emit_enum_version_helper_singleton_name(enum_type)
    enum_constructor_obj_name = (
        emit_fully_qualified_enum_constructor_obj_name(enum_type))
    to_return = '''
public final static VersionHelper<%(enum_name)s> %(singleton_obj_name)s =
    new VersionHelper<%(enum_name)s>(
        new EnumSerializer<%(enum_name)s>(%(enum_constructor_obj_name)s));
''' % { 'enum_name': enum_type.get_emit_name(),
        'singleton_obj_name': singleton_obj_name,
        'enum_constructor_obj_name': enum_constructor_obj_name}
    return to_return

def emit_enum_map_list_variable_factories(enum_type):
    enum_name = enum_type.get_emit_name()
    enum_locked_wrapper_name = emit_enum_locked_map_wrapper_name(enum_type)
    # FIXME: duplicated code with structs
    
    # map deserializers
    param_tuples = (
        ('Double',
         ('ralph.BaseTypeVersionHelpers.' +
             'DOUBLE_KEYED_INTERNAL_MAP_TYPE_VERSION_HELPER')),
        ('String',
         ('ralph.BaseTypeVersionHelpers.' +
             'STRING_KEYED_INTERNAL_MAP_TYPE_VERSION_HELPER')),
        ('Boolean',
         ('ralph.BaseTypeVersionHelpers.' +
             'BOOLEAN_KEYED_INTERNAL_MAP_TYPE_VERSION_HELPER')))
     
    text = ''
    for params in param_tuples:
        key_type = params[0]
        version_helper = params[1]
        
        text += '''
private final static MapVariableFactory<%(key_type)s,%(enum_name)s,%(enum_name)s>
    %(key_type)s_atom_map_serializer_%(enum_name)s =
        new MapVariableFactory<%(key_type)s,%(enum_name)s,%(enum_name)s> (
            %(key_type)s.class, %(enum_name)s.class,
            %(enum_locked_wrapper_name)s,%(version_helper)s);
''' % { 'key_type': key_type,
        'enum_locked_wrapper_name': enum_locked_wrapper_name,
        'enum_name': enum_name,
        'version_helper': version_helper}

    # list deserializers
    text += '''
private final static ListVariableFactory<%(enum_name)s,%(enum_name)s>
    ____atom_list_serializer_%(enum_name)s =
        new ListVariableFactory<%(enum_name)s,%(enum_name)s> (
            %(enum_name)s.class,%(enum_locked_wrapper_name)s);
''' % { 'enum_locked_wrapper_name': enum_locked_wrapper_name,
        'enum_name': enum_name}
    return text



def emit_enum_constructor_obj_and_instance(enum_type):
    '''
    Like endpoints, each enum requires a separate constructor object
    to generate it for replay.  Just need a single constructor for
    each enum.
    '''
    enum_constructor_class_name = emit_enum_constructor_class_name(enum_type)
    enum_constructor_obj_name = emit_enum_constructor_obj_name(enum_type)
    enum_version_helper_name = emit_enum_version_helper_singleton_name(enum_type)

    to_return = '''
public static class %(enum_constructor_class_name)s
    extends EnumConstructorObj < %(enum_name)s> 
{
    @Override
    public AtomicEnumVariable<%(enum_name)s> construct(
        int ordinal,RalphGlobals ralph_globals)
    {
        %(enum_name)s internal_val = construct_enum(ordinal);
        return new AtomicEnumVariable<%(enum_name)s>(
            false,internal_val,this,%(enum_version_helper)s,ralph_globals);
    }

    @Override
    public %(enum_name)s construct_enum(int ordinal)
    {
        %(enum_name)s internal_val = null;
        // -1 ordinal means that held null value
        if (ordinal != -1)
            internal_val = %(enum_name)s.from_ordinal(ordinal);
        return internal_val;
    }
}
// creating this object automatically registers it with version saver.
public static final %(enum_constructor_class_name)s %(enum_constructor_obj_name)s =
    new %(enum_constructor_class_name)s();
''' % {'enum_constructor_class_name' : enum_constructor_class_name,
       'enum_name': enum_type.get_emit_name(),
       'enum_constructor_obj_name': enum_constructor_obj_name,
       'enum_version_helper': enum_version_helper_name}
    
    return to_return


######### HANDLING STRUCTS ########
def emit_internal_struct_type(struct_type):
    return struct_type.prepend_to_name('_Internal')

def emit_struct_definition(struct_name,struct_type,struct_ctx):
    '''
    Each user-defined struct has a wrapper class and an internal
    class.  (Call wrapper class' get_val and set_val to access the
    internal values of the struct.)
    '''
    # Only emit structs for this file.
    where_declared_struct = (
        struct_ctx.get_decl_point_from_struct_name(struct_name))
    
    if struct_ctx.filename != where_declared_struct.filename:
        return ''
    
    dw_constructor_text = emit_struct_data_wrapper_constructor(struct_type)
    external_struct_definition_text = emit_struct_wrapper(struct_type)
    internal_struct_definition_text = emit_internal_struct(struct_type)
    struct_map_wrapper = emit_struct_map_wrapper(struct_type)
    contents_deserializer = emit_struct_content_deserializer(struct_type)
    struct_wrapper_deserializer = emit_struct_wrapper_deserializer(struct_type)
    
    return (
        dw_constructor_text + '\n' +
        external_struct_definition_text + '\n' +
        internal_struct_definition_text + '\n' +
        struct_map_wrapper + '\n' +
        struct_wrapper_deserializer + '\n' +
        contents_deserializer )


def emit_struct_wrapper_deserializer(struct_type):
    struct_name = struct_type.struct_name
    to_return = '''
private static class %(struct_wrapper_class_factory_class_name)s
    implements IAtomicStructWrapperBaseClassFactory
{
    private %(struct_wrapper_class_factory_class_name)s ()
    {
        ContainerFactorySingleton.instance.add_atomic_struct_wrapper_base_class_factory(
             %(struct_name)s.class.getName(),this);
    }
    @Override
    public StructWrapperBaseClass construct(RalphGlobals ralph_globals)
    {
        return new %(struct_name)s (
            // do not log operations
            false,
            ralph_globals);
    }
    @Override
    public StructWrapperBaseClass construct_null_internal(RalphGlobals ralph_globals)
    {
        return new %(struct_name)s (
            // do not log operations
            false,
            // populate internal value with null
            null,
            ralph_globals);
    }

}

private final static %(struct_wrapper_class_factory_class_name)s
    __%(struct_wrapper_class_factory_class_name)s__ =
        new %(struct_wrapper_class_factory_class_name)s();

''' % { 'struct_wrapper_class_factory_class_name': struct_name + '__wrapper_class_factory',
        'struct_name': struct_name }

    return to_return


def emit_struct_content_deserializer(struct_type):
    '''
    Registers map variable factories associated with this struct.
    '''
    internal_struct_name = emit_internal_struct_type(struct_type)
    struct_locked_wrapper_name = emit_struct_locked_map_wrapper_name(
        struct_type)

    # map deserializers
    param_tuples = (
        ('Double',
         ('ralph.BaseTypeVersionHelpers.' +
             'DOUBLE_KEYED_INTERNAL_MAP_TYPE_VERSION_HELPER')),
        ('String',
         ('ralph.BaseTypeVersionHelpers.' +
             'STRING_KEYED_INTERNAL_MAP_TYPE_VERSION_HELPER')),
        ('Boolean',
         ('ralph.BaseTypeVersionHelpers.' +
             'BOOLEAN_KEYED_INTERNAL_MAP_TYPE_VERSION_HELPER')))
     
    text = ''
    for params in param_tuples:
        key_type = params[0]
        version_helper = params[1]
        
        text += '''
private final static MapVariableFactory<%(key_type)s,%(internal_struct_name)s,IReference>
    %(key_type)s_atom_map_serializer_%(internal_struct_name)s =
        new MapVariableFactory<%(key_type)s,%(internal_struct_name)s,IReference> (
            %(key_type)s.class, %(internal_struct_name)s.class,
            %(struct_locked_wrapper_name)s,%(version_helper)s);
''' % { 'key_type': key_type,
        'struct_locked_wrapper_name': struct_locked_wrapper_name,
        'internal_struct_name': internal_struct_name,
        'version_helper': version_helper}

    # list deserializers
    text += '''
private final static ListVariableFactory<%(internal_struct_name)s,IReference>
    ____atom_list_serializer_%(internal_struct_name)s =
        new ListVariableFactory<%(internal_struct_name)s,IReference> (
            %(internal_struct_name)s.class,%(struct_locked_wrapper_name)s);
''' % { 'struct_locked_wrapper_name': struct_locked_wrapper_name,
        'internal_struct_name': internal_struct_name}

    return text
    
def emit_struct_data_wrapper_constructor(struct_type):
    '''
    Each user-defined struct has its own data wrapper const
    '''
    struct_name = struct_type.struct_name
    internal_struct_name = emit_internal_struct_type(struct_type)
    data_wrapper_type_text = (
        'ValueTypeDataWrapperFactory<%s>' %
        (internal_struct_name))

    data_wrapper_constructor_name = struct_data_wrapper_constructor_name(
        struct_name)
    data_wrapper_constructor_text = '''
final static %s
    %s = 
    new %s();
''' % (
        data_wrapper_type_text,data_wrapper_constructor_name,
        data_wrapper_type_text)
    return data_wrapper_constructor_text
    
def struct_data_wrapper_constructor_name(struct_name):
    return '%s_type_data_wrapper_constructor' % struct_name

def emit_struct_map_wrapper(struct_type):
    struct_name = struct_type.struct_name
    internal_struct_name = emit_internal_struct_type(struct_type)
    
    # ensure locked wrappers
    locked_wrappers_text = '''
public static class %s_ensure_atomic_wrapper implements EnsureAtomicWrapper<%s,IReference>
{
    @Override
    public String get_serialization_label()
    {
        return "%s";
    }

    @Override
    public RalphObject<%s,IReference> ensure_atomic_object(
        %s object_to_ensure, RalphGlobals ralph_globals)
    {
        return new %s(false,object_to_ensure,ralph_globals);
    }
}
''' % (struct_name,internal_struct_name,struct_name,
       internal_struct_name,internal_struct_name,struct_name)

    struct_locked_wrapper_name = emit_struct_locked_map_wrapper_name(
        struct_type)
    locked_wrappers_text += '''
// making this public in case external code needs to reference it.
public final static %s_ensure_atomic_wrapper %s = new %s_ensure_atomic_wrapper();
''' % (struct_name, struct_locked_wrapper_name,struct_name)

    return locked_wrappers_text

def emit_enum_locked_map_wrapper_name(enum_type):
    return enum_type.prepend_to_name('ENUM_LOCKED_MAP_WRAPPER__')

def emit_struct_locked_map_wrapper_name(struct_type):
    return struct_type.prepend_to_name(
        'STRUCT_LOCKED_MAP_WRAPPER__')

def emit_struct_wrapper(struct_type):
    '''
    Each user-defined struct gets wrapped by a locked variable that
    points to an internal struct object that has individual fields
    that are multithreaded objects and singlethreaded objects.
    '''
    struct_name = struct_type.struct_name
    internal_struct_name = emit_internal_struct_type(struct_type)
    
    ##### External wrapped struct
    # FIXME: structs are always atomic.
    external_struct_definition_text = '''
public static class %s extends StructWrapperBaseClass<%s>
{''' % (struct_name, internal_struct_name)

    data_wrapper_constructor_name = struct_data_wrapper_constructor_name(
        struct_name)
    
    external_struct_definition_constructor = '''
public %(struct_name)s (boolean log_operations, RalphGlobals ralph_globals)
{
    super(
        log_operations,
        new %(internal_struct_name)s(ralph_globals),
        %(data_wrapper_constructor_name)s,
        /** FIXME: emitting a null logger for structs.*/
        null,
        ralph_globals,
        // no additional serialization contents necessary to log this object
        null);
}

@Override
public boolean return_internal_val_from_container() 
{
    // return internal val when getting from container
    return true;
}

/**
   @param {ActiveEvent} active_event --- Can be null, in which
   case will return internal value without taking any locks.
 */
@Override
public ObjectContents serialize_contents(
    ActiveEvent active_event, Object additional_contents,
    SerializationContext serialization_context)
    throws BackoutException
{
    %(internal_struct_name)s internal_struct = get_val(active_event);
    String internal_reference = null;

    if (internal_struct != null)
    {
        internal_reference = internal_struct.uuid();
        if ( (serialization_context != null) &&
             serialization_context.deep_copy)
        {
            serialization_context.add_to_serialize(internal_struct);
        }
    }

    return ralph.Variables.serialize_struct_reference(
        uuid(),internal_reference, %(struct_name)s.class.getName(),
        true);
}

''' % ({'struct_name': struct_name,
        'internal_struct_name': internal_struct_name,
        'data_wrapper_constructor_name': data_wrapper_constructor_name})
    
    external_struct_definition_constructor += '''
@Override
protected SpeculativeAtomicObject<%s,IReference>
      duplicate_for_speculation(%s to_speculate_on)
{
    ///FIXME: must finish speculation for user-defined structs
    Util.logger_assert(
        "Have not finished duplicate_for_speculation for structs.");
    return null;
}
''' % (internal_struct_name,internal_struct_name)


    # when pass a struct into a method, should clone the struct's
    # wrapper to have pass-by-reference semantics.
    clone_for_args_method_constructor_text = '''
/** Constructor for cloning into args */
public %s (boolean log_operations,%s internal_val,RalphGlobals ralph_globals)
{
    super(
        log_operations,
        internal_val,%s,
        /** FIXME: emitting a null logger for structs.*/
        null,
        ralph_globals, null);
}
''' % (struct_name,internal_struct_name,data_wrapper_constructor_name)

    external_struct_definition_text += indent_string(
        external_struct_definition_constructor +
        clone_for_args_method_constructor_text)
    external_struct_definition_text += '}\n'
    
    return external_struct_definition_text


def emit_internal_struct(struct_type):
    '''
    Each internal struct's fields are single threaded locked and
    unlocked variables.
    '''
    internal_struct_name = emit_internal_struct_type(
        struct_type)
    
    ### Internal wrapped struct    
    internal_struct_definition_text = '''
public static class %(internal_struct_name)s extends InternalStructBaseClass
{
''' % {'internal_struct_name': internal_struct_name}

    # emit struct's fields
    emit_ctx = None
    internal_struct_body_text = ''
    for field_name in struct_type.name_to_field_type_dict:
        field_type = struct_type.name_to_field_type_dict[field_name]
        internal_struct_body_text += (
            'public %s %s = null;\n' %
            (emit_ralph_wrapped_type(field_type),field_name))

    # emit constructor for struct
    internal_struct_body_text += (
        'public %s (RalphGlobals ralph_globals)\n' %
        internal_struct_name)
    internal_struct_body_text += '''{
    // inherits from InternalStructBaseClass
    super(ralph_globals);
'''
    internal_constructor_text = ''
    initializer_dict = struct_type.name_to_initializer_dict
    for field_name in struct_type.name_to_field_type_dict:
        field_type = struct_type.name_to_field_type_dict[field_name]

        initializer_node = initializer_dict.get(field_name,None)
        internal_constructor_text += (
            '%s = %s;\n' %
            (field_name,
             construct_new_expression(field_type,initializer_node,emit_ctx)))
    # registers struct with version manager, if on.
    internal_constructor_text += '\nlog_obj_constructor_during_init(null);\n'
        
    internal_struct_body_text += indent_string(internal_constructor_text)
    internal_struct_body_text += '}\n'

    # emit other methods of internal struct 
    internal_struct_body_text += (
        emit_internal_struct_replay_and_deserialize(struct_type))
    internal_struct_body_text += (
        emit_internal_struct_serialize_contents(struct_type))
    
    internal_struct_definition_text += indent_string(
        internal_struct_body_text)
    internal_struct_definition_text += '\n}'
    return internal_struct_definition_text


def emit_internal_struct_replay_and_deserialize(struct_type):
    internal_replay_text = ''
    internal_deserialize_text = ''
    # note that it's important to add these in alphabetically sorted
    # order.  deserializer, expects them in alphabetically sorted
    # order
    sorted_field_keys = sorted(struct_type.name_to_field_type_dict.keys())
    for field_index in range (0, len(sorted_field_keys)):
        field_name = sorted_field_keys[field_index]
        field_type = struct_type.name_to_field_type_dict[field_name]
        field_type_text = emit_ralph_wrapped_type(field_type)
        internal_replay_text += '''
{
    %(field_name)s =
        (%(field_type)s) reconstruction_context.get_constructed_object(
            internal_references_to_replay_on.get(%(field_index)i),
            to_play_until);
}
''' % { 'field_name': field_name,
        'field_index': field_index,
        'field_type': field_type_text}

        internal_deserialize_text += '''
{
    %(field_name)s.set_val(act_event,
        ((%(field_type)s) reconstruction_context.get_constructed_object(
            internal_references_to_replay_on.get(%(field_index)i),
            to_play_until)).get_val(act_event));
}
''' % { 'field_name': field_name,
        'field_index': field_index,
        'field_type': field_type_text}


    internal_replay_text = indent_string(internal_replay_text)
    replay_text = '''
@Override
public void replay (
    IReconstructionContext reconstruction_context,
    ObjectHistory obj_history,Long to_play_until)
{
    if (internal_references_to_replay_on == null)
    {
        Util.logger_assert(
            "Internal struct must have internal_references_to_replay_on set");
    }


%(internal_replay_text)s
}
''' % { 'internal_replay_text': internal_replay_text}

    deserialize_text = '''
@Override
public void deserialize (
    IReconstructionContext reconstruction_context,
    ObjectHistory obj_history,Long to_play_until,
    ActiveEvent act_event) throws BackoutException
{
    if (internal_references_to_replay_on == null)
    {
        Util.logger_assert(
            "Internal struct must have internal_references_to_replay_on set");
    }


%(internal_deserialize_text)s
}
''' % { 'internal_deserialize_text': internal_deserialize_text}

    return replay_text + deserialize_text


def emit_internal_struct_serialize_contents(struct_type):
    '''
    '''
    struct_name = struct_type.struct_name
    internal_struct_builder_var_name = 'internal_struct_builder'
    field_serialization_text = ''
    
    # note that it's important to add these in alphabetically sorted
    # order.  deserializer, expects them in alphabetically sorted order
    for field_name in sorted(struct_type.name_to_field_type_dict.keys()):
        field_serialization_text += '''
Delta.ReferenceType.Builder %(reference_type_var_name)s =
    Delta.ReferenceType.newBuilder();

%(reference_type_var_name)s.setReference( %(field_name)s.uuid());

ObjectContents.InternalStructField.Builder %(internal_struct_field_var_name)s =
    ObjectContents.InternalStructField.newBuilder();

%(internal_struct_field_var_name)s.setFieldContentsReference(%(reference_type_var_name)s);

%(internal_struct_builder_var_name)s.addFields(%(internal_struct_field_var_name)s);

if ( (serialization_context != null) &&
     serialization_context.deep_copy)
{
    serialization_context.add_to_serialize(%(field_name)s);
}

''' % { 'reference_type_var_name': field_name + '___ref_type_var_name__',
        'field_name': field_name,
        'internal_struct_field_var_name': field_name + '___internal_struct_field_var_name__',
        'internal_struct_builder_var_name': internal_struct_builder_var_name}

    # FIXME: only allowing atomic internal structs during
    # serialization.  (Note set_atomic is hard coded true.)
    return '''
@Override
public ObjectContents serialize_contents(
    ActiveEvent active_event,Object add_contents,SerializationContext serialization_context)
{
    ObjectContents.InternalStruct.Builder %(internal_struct_builder_var_name)s =
        ObjectContents.InternalStruct.newBuilder();
    %(internal_struct_builder_var_name)s.setStructTypeClassName(%(struct_name)s.class.getName());

%(field_serialization_text)s

    ObjectContents.Builder to_return = ObjectContents.newBuilder();
    to_return.setAtomic(true);
    to_return.setUuid(uuid());
    to_return.setInternalStructType(%(internal_struct_builder_var_name)s);
    return to_return.build();
}
''' % {'field_serialization_text': indent_string(field_serialization_text),
       'internal_struct_builder_var_name': internal_struct_builder_var_name,
       'struct_name': struct_name}
